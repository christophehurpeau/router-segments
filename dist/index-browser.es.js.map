{"version":3,"file":"index-browser.es.js","sources":["../src/router/findMatch.ts","../src/router/createRouter.ts","../src/utils/getKeys.ts","../src/routes/LocalizedEndRoute.ts","../src/routes/LocalizedSegmentRoute.ts","../src/routes/NotLocalizedEndRoute.ts","../src/routes/NotLocalizedSegmentRoute.ts","../src/routes/createRoutePath.ts","../src/routes/create.ts","../src/builder/createSegmentRouterBuilderCreator.ts","../src/builder/createRouterBuilder.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport { IS_DEV } from 'pob-babel';\nimport { Logger } from 'nightingale-logger';\nimport type { EndRoute, Route, SegmentRoute } from '../routes/interfaces';\nimport type {\n  LocaleType,\n  RoutePathInterface,\n  SegmentRoutePath,\n  EndRoutePath,\n} from '../types';\n\nexport interface RouteMatch<Locales extends LocaleType | never, RouteRef> {\n  namedParams: Map<string, string> | undefined;\n  otherParams: string[] | undefined;\n  path: string;\n  ref: RouteRef;\n  route: Route<any, Locales, RouteRef>;\n  routePath: EndRoutePath | SegmentRoutePath;\n}\n\nconst logger = IS_DEV ? new Logger('router-segments:findMatch') : undefined;\n\nconst parseOtherParams = (wildcard: string): string[] =>\n  wildcard ? wildcard.split('/') : [];\n\ninterface InternalFindMatchParams<Locales extends LocaleType, RouteRef> {\n  path: string;\n  completePath: string;\n  routes: Route<RoutePathInterface, Locales, RouteRef>[];\n  locale?: Locales;\n  namedParams?: Map<number | string, string>;\n}\n\nconst internalFindMatch = <Locales extends LocaleType, RouteRef>({\n  path,\n  completePath,\n  routes,\n  locale = 'en' as Locales,\n  namedParams,\n}: InternalFindMatchParams<Locales, RouteRef>): RouteMatch<\n  Locales,\n  RouteRef\n> | null => {\n  let result = null;\n\n  routes.some((route): boolean => {\n    const routePath: RoutePathInterface = route.getPath(locale);\n    const isDev = IS_DEV;\n\n    if (isDev && !routePath) {\n      throw new Error(`Unknown localized route for locale ${locale}`);\n    }\n\n    /* istanbul ignore next */\n    if (isDev && logger) {\n      logger.debug(`trying ${routePath.regExp.toString()}`);\n    }\n\n    const match = routePath.regExp.exec(path);\n    // logger.info('trytomatch', { path, regExp: routePath.regExp, match });\n    if (!match) return false;\n\n    match.shift(); // remove m[0], === path;\n\n    let groupCount = match.length;\n    let group = 0;\n\n    if (routePath.namedParams.length > 0) {\n      // set params\n      if (!namedParams) namedParams = new Map();\n\n      routePath.namedParams.forEach((paramName: number | string) => {\n        namedParams!.set(paramName, match[group++]);\n      });\n    }\n\n    if (route.isSegment()) {\n      const segment = route as SegmentRoute<Locales, RouteRef>;\n      const restOfThePath = match[--groupCount];\n\n      if (restOfThePath) {\n        result = internalFindMatch({\n          path: `/${restOfThePath}`,\n          completePath,\n          routes: segment.nestedRoutes,\n          locale,\n          namedParams,\n        });\n\n        return result !== null;\n      }\n\n      if (!segment.defaultRoute) {\n        return false;\n      }\n\n      route = segment.defaultRoute;\n    }\n\n    const endRoute = route as EndRoute<Locales, RouteRef>;\n\n    const otherParams =\n      group + 1 !== groupCount ? undefined : parseOtherParams(match[group]);\n\n    result = Object.freeze({\n      ref: endRoute.ref,\n      path: completePath,\n      route: endRoute,\n      routePath,\n      namedParams,\n      otherParams,\n    });\n\n    return true;\n  });\n\n  return result;\n};\n\nexport function findMatch<Locales extends LocaleType, RouteRef>(\n  path: string,\n  routes: Route<RoutePathInterface, Locales, RouteRef>[],\n  locale?: Locales,\n): RouteMatch<Locales, RouteRef> | null {\n  return internalFindMatch({ path, completePath: path, routes, locale });\n}\n","import type { EndRoute } from '../routes/interfaces';\nimport type { Routes, RouteMap, LocaleType } from '../types';\nimport type { RouteMatch } from './findMatch';\nimport { findMatch } from './findMatch';\n\nexport interface Router<Locales extends LocaleType | never, RouteRef> {\n  get: (key: string) => EndRoute<Locales, RouteRef>;\n  find: (\n    path: string,\n    locale?: Locales,\n  ) => RouteMatch<Locales, RouteRef> | null;\n  toLocalizedPath: (locale: Locales, key: string, args?: any) => string;\n  toPath: (key: string, args?: any) => string;\n}\n\nexport function createRouter<Locales extends LocaleType | never, RouteRef>(\n  routes: Routes<Locales, RouteRef>,\n  routeMap: RouteMap<Locales, RouteRef>,\n): Router<Locales, RouteRef> {\n  const getRequiredRoute = (routeKey: string): EndRoute<Locales, RouteRef> => {\n    const route = routeMap.get(routeKey);\n    if (!route) throw new Error(`No route named \"${routeKey}\"`);\n    return route;\n  };\n\n  return {\n    get: getRequiredRoute,\n    find: (\n      path: string,\n      locale?: Locales,\n    ): RouteMatch<Locales, RouteRef> | null => findMatch(path, routes, locale),\n    toPath: (key: string, args?: Record<string, any>): string =>\n      getRequiredRoute(key).getPath().toPath(args),\n    toLocalizedPath: (\n      locale: Locales,\n      key: string,\n      args?: Record<string, any>,\n    ): string => getRequiredRoute(key).getPath(locale).toPath(args),\n  };\n}\n","export const getKeys = <T extends Record<string, unknown>>(o: T): (keyof T)[] =>\n  Object.keys(o) as (keyof T)[];\n","import type { EndRoute, LocalizedRoute } from './interfaces';\nimport type { LocaleType, EndRoutePath } from './types';\n\nexport class LocalizedEndRoute<Locales extends LocaleType, RouteRef>\n  implements\n    EndRoute<Locales, RouteRef>,\n    LocalizedRoute<EndRoutePath, Locales, RouteRef>\n{\n  localizedPaths: Map<LocaleType, EndRoutePath>;\n\n  ref: RouteRef;\n\n  constructor(localizedPaths: Map<LocaleType, EndRoutePath>, ref: RouteRef) {\n    this.localizedPaths = localizedPaths;\n\n    this.ref = ref;\n    Object.freeze(this);\n  }\n\n  getPath(locale?: Locales): EndRoutePath {\n    if (!locale) throw new Error('Missing locale');\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { LocalizedEndRoute } from './LocalizedEndRoute';\nimport type { SegmentRoute, LocalizedRoute } from './interfaces';\nimport type { LocaleType, SegmentRoutePath } from './types';\n\nexport class LocalizedSegmentRoute<Locales extends LocaleType, RouteRef>\n  implements\n    SegmentRoute<Locales, RouteRef>,\n    LocalizedRoute<SegmentRoutePath, Locales, RouteRef>\n{\n  localizedPaths: Map<Locales, SegmentRoutePath>;\n\n  nestedRoutes: LocalizedRoute<any, Locales, RouteRef>[] = [];\n\n  defaultRoute: LocalizedEndRoute<Locales, RouteRef> | undefined;\n\n  constructor(localizedPaths: Map<Locales, SegmentRoutePath>) {\n    this.localizedPaths = localizedPaths;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(locale?: Locales): SegmentRoutePath {\n    if (!locale) throw new Error('Missing locale');\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { EndRoute, NotLocalizedRoute } from './interfaces';\nimport type { EndRoutePath, LocaleType } from './types';\n\nexport class NotLocalizedEndRoute<Locales extends LocaleType, RouteRef>\n  implements\n    EndRoute<Locales, RouteRef>,\n    NotLocalizedRoute<EndRoutePath, Locales, RouteRef>\n{\n  path: EndRoutePath;\n\n  ref: RouteRef;\n\n  constructor(path: EndRoutePath, ref: RouteRef) {\n    this.path = path;\n\n    this.ref = ref;\n    // Object.freeze(this);\n  }\n\n  getPath(): EndRoutePath {\n    return this.path;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { NotLocalizedEndRoute } from './NotLocalizedEndRoute';\nimport type { SegmentRoute, NotLocalizedRoute } from './interfaces';\nimport type { LocaleType, SegmentRoutePath } from './types';\n\nexport class NotLocalizedSegmentRoute<Locales extends LocaleType, RouteRef>\n  implements\n    SegmentRoute<Locales, RouteRef>,\n    NotLocalizedRoute<SegmentRoutePath, Locales, RouteRef>\n{\n  path: SegmentRoutePath;\n\n  nestedRoutes: NotLocalizedRoute<any, Locales, RouteRef>[] = [];\n\n  defaultRoute: NotLocalizedEndRoute<Locales, RouteRef> | undefined;\n\n  constructor(path: SegmentRoutePath) {\n    this.path = path;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(): SegmentRoutePath {\n    return this.path;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { Key } from 'path-to-regexp';\nimport { pathToRegexp, compile } from 'path-to-regexp';\nimport type { SegmentRoutePath, EndRoutePath } from '../types';\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: true,\n): SegmentRoutePath;\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: false,\n): EndRoutePath;\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: boolean,\n): EndRoutePath | SegmentRoutePath {\n  const keys: Key[] = [];\n  const regExp = pathToRegexp(segment ? `${path}/(.*)?` : path, keys, {\n    sensitive: true,\n    strict: true,\n  });\n  const namedParams = keys.map((key) => key.name).filter(Boolean);\n\n  if (segment) return { path, completePath, regExp, namedParams };\n\n  return {\n    path,\n    completePath,\n    regExp,\n    namedParams,\n    toPath: compile(completePath),\n  };\n}\n\nexport const createRoutePathSegment = (\n  path: string,\n  completePath: string,\n): SegmentRoutePath => internalCreateRoutePath(path, completePath, true);\n\nexport const createRoutePath = (\n  path: string,\n  completePath: string,\n): EndRoutePath => internalCreateRoutePath(path, completePath, false);\n","import { IS_DEV } from 'pob-babel';\nimport type {\n  LocaleType,\n  LocalizedPathsRecord,\n  EndRoutePath,\n  SegmentRoutePath,\n} from '../types';\nimport { getKeys } from '../utils/getKeys';\nimport { LocalizedEndRoute } from './LocalizedEndRoute';\nimport { LocalizedSegmentRoute } from './LocalizedSegmentRoute';\nimport { NotLocalizedEndRoute as Route } from './NotLocalizedEndRoute';\nimport { NotLocalizedSegmentRoute } from './NotLocalizedSegmentRoute';\nimport { createRoutePath, createRoutePathSegment } from './createRoutePath';\n\nconst createLocalizedPaths = <\n  Locales extends LocaleType,\n  Path extends EndRoutePath | SegmentRoutePath,\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  segment: boolean,\n): Map<Locales, Path> => {\n  const localizedPaths = new Map<Locales, Path>();\n  getKeys(localizedPathsRecord).forEach((locale: Locales) => {\n    const path = localizedPathsRecord[locale];\n    if (segment) {\n      const routerPath: SegmentRoutePath = createRoutePathSegment(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    } else {\n      const routerPath: EndRoutePath = createRoutePath(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    }\n  });\n  return localizedPaths;\n};\n\nconst checkRef = <RouteRef>(ref: RouteRef): void => {\n  if (!ref) throw new Error(`Invalid ref: \"${JSON.stringify(ref)}\"`);\n};\n\nexport const createRoute = <Locales extends LocaleType, RouteRef>(\n  path: string,\n  completePath: string,\n  ref: RouteRef,\n): Route<Locales, RouteRef> => {\n  /* istanbul ignore if */\n  if (IS_DEV) checkRef(ref);\n  const routePath: EndRoutePath = createRoutePath(path, completePath);\n  return new Route(routePath, ref);\n};\n\nexport const createLocalizedRoute = <Locales extends LocaleType, RouteRef>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  ref: RouteRef,\n): LocalizedEndRoute<Locales, RouteRef> => {\n  /* istanbul ignore if */\n  if (IS_DEV) checkRef(ref);\n  const localizedPaths = createLocalizedPaths<Locales, EndRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    false,\n  );\n  return new LocalizedEndRoute(localizedPaths, ref);\n};\n\nexport const createSegmentRoute = <Locales extends LocaleType, RouteRef>(\n  path: string,\n  completePath: string,\n): NotLocalizedSegmentRoute<Locales, RouteRef> => {\n  const routePath = createRoutePathSegment(path, completePath);\n  return new NotLocalizedSegmentRoute(routePath);\n};\n\nexport const createLocalizedSegmentRoute = <\n  Locales extends LocaleType,\n  RouteRef,\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n): LocalizedSegmentRoute<Locales, RouteRef> => {\n  const localizedPaths = createLocalizedPaths<Locales, SegmentRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    true,\n  );\n  return new LocalizedSegmentRoute(localizedPaths);\n};\n","import type { LocalizedSegmentRoute, LocalizedEndRoute } from '../routes';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\nimport type { EndRoute, SegmentRoute } from '../routes/interfaces';\nimport type { LocalizedPathsRecord, LocaleType } from '../types';\nimport { getKeys } from '../utils/getKeys';\n\nexport interface SegmentRouterBuilder<Locales extends LocaleType, RouteRef> {\n  add: (path: string, ref: RouteRef, key?: string) => void;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => void;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => void;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => void;\n  defaultRoute: (ref: RouteRef, key?: string) => void;\n}\n\nexport function createSegmentRouterBuilderCreator<\n  Locales extends LocaleType,\n  RouteRef,\n>(\n  defaultLocale: Locales | undefined,\n  addToRouteMap: (key: string, route: EndRoute<Locales, RouteRef>) => void,\n): (\n  segmentRoute: SegmentRoute<Locales, RouteRef>,\n) => SegmentRouterBuilder<Locales, RouteRef> {\n  const createSegmentRouterBuilder = (\n    segmentRoute: SegmentRoute<Locales, RouteRef>,\n  ): SegmentRouterBuilder<Locales, RouteRef> => {\n    const getCompletePath = (path: string, locale?: Locales): string =>\n      `${segmentRoute.getPath(locale).completePath}${path}`;\n\n    const getCompleteLocalizedPaths = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n    ): LocalizedPathsRecord<Locales> => {\n      const completeLocalizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n\n      getKeys(localizedPaths).forEach((locale: Locales) => {\n        completeLocalizedPaths[locale] = getCompletePath(\n          localizedPaths[locale],\n          locale,\n        );\n      });\n\n      return completeLocalizedPaths;\n    };\n\n    const createLocalizedPathFromSegment = (\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      segmentRoute: LocalizedSegmentRoute<Locales, RouteRef>,\n      path: string,\n    ): Record<Locales, string> => {\n      const localizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n      [...segmentRoute.localizedPaths.keys()].forEach((locale) => {\n        localizedPaths[locale] = path;\n      });\n      return localizedPaths;\n    };\n\n    const _createLocalizedEndRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ): LocalizedEndRoute<Locales, RouteRef> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const finalKey: string = key || completeLocalizedPaths[defaultLocale!];\n      const route = createLocalizedRoute(\n        localizedPaths,\n        completeLocalizedPaths,\n        ref,\n      );\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createEndRoute = (\n      path: string,\n      ref: RouteRef,\n      key?: string,\n    ): EndRoute<Locales, RouteRef> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedEndRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales, RouteRef>,\n            path,\n          ),\n          ref,\n          key,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createRoute(path, completePath, ref);\n      const finalKey: string = key || completePath;\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createLocalizedSegmentRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ): LocalizedSegmentRoute<Locales, RouteRef> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const route = createLocalizedSegmentRoute<Locales, RouteRef>(\n        localizedPaths,\n        completeLocalizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    const _createSegmentRoute = (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ): SegmentRoute<Locales, RouteRef> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedSegmentRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales, RouteRef>,\n            path,\n          ),\n          buildSegment,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createSegmentRoute<Locales, RouteRef>(path, completePath);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    return {\n      defaultRoute: (ref: RouteRef, key?: string): void => {\n        segmentRoute.defaultRoute = _createEndRoute('', ref, key);\n      },\n\n      add: (path: string, ref: RouteRef, key?: string): void => {\n        segmentRoute.nestedRoutes.push(_createEndRoute(path, ref, key));\n      },\n\n      addLocalized: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        ref: RouteRef,\n        key?: string,\n      ): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedEndRoute(localizedPaths, ref, key),\n        );\n      },\n\n      addSegment: (\n        path: string,\n        buildSegment: (\n          builder: SegmentRouterBuilder<Locales, RouteRef>,\n        ) => void,\n      ): void => {\n        segmentRoute.nestedRoutes.push(_createSegmentRoute(path, buildSegment));\n      },\n\n      addLocalizedSegment: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        buildSegment: (\n          builder: SegmentRouterBuilder<Locales, RouteRef>,\n        ) => void,\n      ): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedSegmentRoute(localizedPaths, buildSegment),\n        );\n      },\n    };\n  };\n  return createSegmentRouterBuilder;\n}\n","import type { Router } from '../router/createRouter';\nimport { createRouter } from '../router/createRouter';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\nimport type { EndRoute } from '../routes/interfaces';\nimport type {\n  LocaleType,\n  LocalizedPathsRecord,\n  Routes,\n  RouteMap,\n} from '../types';\nimport type { SegmentRouterBuilder } from './createSegmentRouterBuilderCreator';\nimport { createSegmentRouterBuilderCreator } from './createSegmentRouterBuilderCreator';\n\nexport interface RouterBuilder<Locales extends LocaleType | never, RouteRef> {\n  add: (path: string, ref: RouteRef, key?: string) => this;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => this;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => this;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => this;\n  createRouter: () => Router<Locales, RouteRef>;\n  getRoutes: () => Routes<Locales, RouteRef>;\n}\n\nexport function createRouterBuilder<Locales extends LocaleType, RouteRef>(\n  locales?: Locales[],\n): RouterBuilder<Locales, RouteRef> {\n  const defaultLocale = locales?.[0];\n  const routes: Routes<Locales, RouteRef> = [];\n  const routeMap: RouteMap<Locales, RouteRef> = new Map<\n    string,\n    EndRoute<Locales, RouteRef>\n  >();\n\n  const addToRouteMap = (\n    key: string,\n    route: EndRoute<Locales, RouteRef>,\n  ): void => {\n    if (routeMap.has(key)) throw new Error(`\"${key}\" is already used`);\n    routeMap.set(key, route);\n  };\n\n  const createSegmentRouterBuilder = createSegmentRouterBuilderCreator(\n    defaultLocale,\n    addToRouteMap,\n  );\n\n  const builder: RouterBuilder<Locales, RouteRef> = {\n    add: (path: string, ref: RouteRef, key?: string) => {\n      const route = createRoute(path, path, ref);\n      routes.push(route);\n      if (!key) key = path;\n      addToRouteMap(key, route);\n      return builder;\n    },\n\n    addLocalized: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ) => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedRoute(localizedPaths, localizedPaths, ref);\n      routes.push(route);\n      const finalKey: string = key || localizedPaths[defaultLocale];\n      addToRouteMap(finalKey, route);\n      return builder;\n    },\n\n    addSegment: (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ) => {\n      const route = createSegmentRoute<Locales, RouteRef>(path, path);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n      return builder;\n    },\n\n    addLocalizedSegment: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ) => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedSegmentRoute<Locales, RouteRef>(\n        localizedPaths,\n        localizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n      return builder;\n    },\n\n    getRoutes: () => routes,\n    createRouter: () => createRouter(routes, routeMap),\n  };\n  return builder;\n}\n"],"names":["logger","process","env","NODE_ENV","Logger","undefined","parseOtherParams","wildcard","split","internalFindMatch","_ref","path","completePath","routes","_ref$locale","locale","namedParams","result","some","route","routePath","getPath","segment","restOfThePath","isDev","Error","debug","regExp","toString","match","exec","shift","groupCount","length","group","Map","forEach","paramName","set","isSegment","nestedRoutes","defaultRoute","endRoute","otherParams","Object","freeze","ref","findMatch","createRouter","routeMap","getRequiredRoute","routeKey","get","find","toPath","key","args","toLocalizedPath","getKeys","o","keys","LocalizedEndRoute","localizedPaths","_proto","prototype","isLocalized","toJSON","concat","entries","JSON","stringify","LocalizedSegmentRoute","NotLocalizedEndRoute","NotLocalizedSegmentRoute","internalCreateRoutePath","pathToRegexp","sensitive","strict","map","name","filter","Boolean","compile","createRoutePathSegment","createRoutePath","createLocalizedPaths","localizedPathsRecord","completeLocalizedPathsRecord","routerPath","checkRef","createRoute","Route","createLocalizedRoute","createSegmentRoute","createLocalizedSegmentRoute","createSegmentRouterBuilderCreator","defaultLocale","addToRouteMap","createSegmentRouterBuilder","segmentRoute","getCompletePath","getCompleteLocalizedPaths","completeLocalizedPaths","createLocalizedPathFromSegment","_createLocalizedEndRoute","finalKey","_createEndRoute","_createLocalizedSegmentRoute","buildSegment","_createSegmentRoute","add","push","addLocalized","addSegment","addLocalizedSegment","createRouterBuilder","locales","has","builder","getRoutes"],"mappings":"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"}