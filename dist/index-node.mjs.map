{"version":3,"file":"index-node.mjs","sources":["../src/router/findMatch.ts","../src/router/createRouter.ts","../src/utils/getKeys.ts","../src/routes/LocalizedEndRoute.ts","../src/routes/LocalizedSegmentRoute.ts","../src/routes/NotLocalizedEndRoute.ts","../src/routes/NotLocalizedSegmentRoute.ts","../src/routes/createRoutePath.ts","../src/routes/create.ts","../src/builder/createSegmentRouterBuilderCreator.ts","../src/builder/createRouterBuilder.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport { Logger } from \"nightingale-logger\";\nimport type { EndRoute, Route, SegmentRoute } from \"../routes/interfaces\";\nimport type {\n  EndRoutePath,\n  LocaleType,\n  RoutePathInterface,\n  SegmentRoutePath,\n} from \"../types\";\n\nexport interface RouteMatch<Locales extends LocaleType | never, RouteRef> {\n  namedParams: Map<string, string> | undefined;\n  path: string;\n  ref: RouteRef;\n  route: Route<any, Locales, RouteRef>;\n  routePath: EndRoutePath | SegmentRoutePath;\n}\n\nconst logger =\n  process.env.NODE_ENV !== \"production\"\n    ? new Logger(\"router-segments:findMatch\")\n    : undefined;\n\ninterface InternalFindMatchParams<Locales extends LocaleType, RouteRef> {\n  path: string;\n  completePath: string;\n  routes: Route<RoutePathInterface, Locales, RouteRef>[];\n  locale?: Locales;\n  namedParams?: Map<number | string, string>;\n}\n\nconst internalFindMatch = <Locales extends LocaleType, RouteRef>({\n  path,\n  completePath,\n  routes,\n  locale = \"en\" as Locales,\n  namedParams,\n}: InternalFindMatchParams<Locales, RouteRef>): RouteMatch<\n  Locales,\n  RouteRef\n> | null => {\n  let result = null;\n\n  routes.some((route): boolean => {\n    const routePath: RoutePathInterface = route.getPath(locale);\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\" && !routePath) {\n      throw new Error(`Unknown localized route for locale ${locale}`);\n    }\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\" && logger) {\n      logger.debug(`trying ${routePath.regExp.toString()}`);\n    }\n\n    const match = routePath.regExp.exec(path);\n    // logger.info('trytomatch', { path, regExp: routePath.regExp, match });\n    if (!match) return false;\n\n    const matchedValue = match[0]; // remove m[0], === path;\n\n    if (routePath.namedParams.length > 0) {\n      let group = 1;\n      // set params\n      if (!namedParams) namedParams = new Map();\n\n      routePath.namedParams.forEach((paramName: number | string) => {\n        const paramValue = match[group++];\n        if (paramValue !== undefined || !namedParams!.has(paramName)) {\n          namedParams!.set(paramName, paramValue!);\n        }\n      });\n    }\n\n    if (route.isSegment()) {\n      const segment = route as SegmentRoute<Locales, RouteRef>;\n      const restOfThePath = path.slice(matchedValue.length + 1);\n\n      if (restOfThePath) {\n        result = internalFindMatch({\n          path: `/${restOfThePath}`,\n          completePath,\n          routes: segment.nestedRoutes,\n          locale,\n          namedParams,\n        });\n\n        return result !== null;\n      }\n\n      if (!segment.defaultRoute) {\n        return false;\n      }\n\n      route = segment.defaultRoute;\n    }\n\n    const endRoute = route as EndRoute<Locales, RouteRef>;\n\n    result = Object.freeze({\n      ref: endRoute.ref,\n      path: completePath,\n      route: endRoute,\n      routePath,\n      namedParams,\n    });\n\n    return true;\n  });\n\n  return result;\n};\n\nexport function findMatch<Locales extends LocaleType, RouteRef>(\n  path: string,\n  routes: Route<RoutePathInterface, Locales, RouteRef>[],\n  locale?: Locales,\n): RouteMatch<Locales, RouteRef> | null {\n  return internalFindMatch({ path, completePath: path, routes, locale });\n}\n","import type { EndRoute } from \"../routes/interfaces.ts\";\nimport type { LocaleType, RouteMap, Routes } from \"../types.ts\";\nimport type { RouteMatch } from \"./findMatch.ts\";\nimport { findMatch } from \"./findMatch.ts\";\n\nexport interface Router<Locales extends LocaleType | never, RouteRef> {\n  get: (key: string) => EndRoute<Locales, RouteRef>;\n  find: (\n    path: string,\n    locale?: Locales,\n  ) => RouteMatch<Locales, RouteRef> | null;\n  toLocalizedPath: (locale: Locales, key: string, args?: any) => string;\n  toPath: (key: string, args?: any) => string;\n}\n\nexport function createRouter<Locales extends LocaleType | never, RouteRef>(\n  routes: Routes<Locales, RouteRef>,\n  routeMap: RouteMap<Locales, RouteRef>,\n): Router<Locales, RouteRef> {\n  const getRequiredRoute = (routeKey: string): EndRoute<Locales, RouteRef> => {\n    const route = routeMap.get(routeKey);\n    if (!route) throw new Error(`No route named \"${routeKey}\"`);\n    return route;\n  };\n\n  return {\n    get: getRequiredRoute,\n    find: (\n      path: string,\n      locale?: Locales,\n    ): RouteMatch<Locales, RouteRef> | null => findMatch(path, routes, locale),\n    toPath: (key: string, args?: Record<string, any>): string =>\n      getRequiredRoute(key).getPath().toPath(args),\n    toLocalizedPath: (\n      locale: Locales,\n      key: string,\n      args?: Record<string, any>,\n    ): string => getRequiredRoute(key).getPath(locale).toPath(args),\n  };\n}\n","export const getKeys = <T extends Record<string, unknown>>(o: T): (keyof T)[] =>\n  Object.keys(o) as (keyof T)[];\n","import type { EndRoute, LocalizedRoute } from \"./interfaces\";\nimport type { EndRoutePath, LocaleType } from \"./types\";\n\nexport class LocalizedEndRoute<Locales extends LocaleType, RouteRef>\n  implements\n    EndRoute<Locales, RouteRef>,\n    LocalizedRoute<EndRoutePath, Locales, RouteRef>\n{\n  localizedPaths: Map<LocaleType, EndRoutePath>;\n\n  ref: RouteRef;\n\n  constructor(localizedPaths: Map<LocaleType, EndRoutePath>, ref: RouteRef) {\n    this.localizedPaths = localizedPaths;\n\n    this.ref = ref;\n    Object.freeze(this);\n  }\n\n  getPath(locale?: Locales): EndRoutePath {\n    if (!locale) throw new Error(\"Missing locale\");\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { LocalizedEndRoute } from \"./LocalizedEndRoute\";\nimport type { LocalizedRoute, SegmentRoute } from \"./interfaces\";\nimport type { LocaleType, SegmentRoutePath } from \"./types\";\n\nexport class LocalizedSegmentRoute<Locales extends LocaleType, RouteRef>\n  implements\n    SegmentRoute<Locales, RouteRef>,\n    LocalizedRoute<SegmentRoutePath, Locales, RouteRef>\n{\n  localizedPaths: Map<Locales, SegmentRoutePath>;\n\n  nestedRoutes: LocalizedRoute<any, Locales, RouteRef>[] = [];\n\n  defaultRoute: LocalizedEndRoute<Locales, RouteRef> | undefined;\n\n  constructor(localizedPaths: Map<Locales, SegmentRoutePath>) {\n    this.localizedPaths = localizedPaths;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(locale?: Locales): SegmentRoutePath {\n    if (!locale) throw new Error(\"Missing locale\");\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { EndRoute, NotLocalizedRoute } from \"./interfaces\";\nimport type { EndRoutePath, LocaleType } from \"./types\";\n\nexport class NotLocalizedEndRoute<Locales extends LocaleType, RouteRef>\n  implements\n    EndRoute<Locales, RouteRef>,\n    NotLocalizedRoute<EndRoutePath, Locales, RouteRef>\n{\n  path: EndRoutePath;\n\n  ref: RouteRef;\n\n  constructor(path: EndRoutePath, ref: RouteRef) {\n    this.path = path;\n\n    this.ref = ref;\n    // Object.freeze(this);\n  }\n\n  getPath(): EndRoutePath {\n    return this.path;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { NotLocalizedEndRoute } from \"./NotLocalizedEndRoute\";\nimport type { NotLocalizedRoute, SegmentRoute } from \"./interfaces\";\nimport type { LocaleType, SegmentRoutePath } from \"./types\";\n\nexport class NotLocalizedSegmentRoute<Locales extends LocaleType, RouteRef>\n  implements\n    SegmentRoute<Locales, RouteRef>,\n    NotLocalizedRoute<SegmentRoutePath, Locales, RouteRef>\n{\n  path: SegmentRoutePath;\n\n  nestedRoutes: NotLocalizedRoute<any, Locales, RouteRef>[] = [];\n\n  defaultRoute: NotLocalizedEndRoute<Locales, RouteRef> | undefined;\n\n  constructor(path: SegmentRoutePath) {\n    this.path = path;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(): SegmentRoutePath {\n    return this.path;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import { compile, pathToRegexp } from \"path-to-regexp\";\nimport type { EndRoutePath, SegmentRoutePath } from \"../types\";\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: true,\n): SegmentRoutePath;\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: false,\n): EndRoutePath;\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: boolean,\n): EndRoutePath | SegmentRoutePath {\n  const { keys, regexp: regExp } = pathToRegexp(path, {\n    sensitive: true,\n    trailing: false,\n    end: !segment,\n  });\n\n  const namedParams = keys.map((key) => key.name).filter(Boolean);\n\n  if (segment) return { path, completePath, regExp, namedParams };\n\n  return {\n    path,\n    completePath,\n    regExp,\n    namedParams,\n    toPath: compile(completePath),\n  };\n}\n\nexport const createRoutePathSegment = (\n  path: string,\n  completePath: string,\n): SegmentRoutePath => internalCreateRoutePath(path, completePath, true);\n\nexport const createRoutePath = (\n  path: string,\n  completePath: string,\n): EndRoutePath => internalCreateRoutePath(path, completePath, false);\n","import type {\n  EndRoutePath,\n  LocaleType,\n  LocalizedPathsRecord,\n  SegmentRoutePath,\n} from \"../types.ts\";\nimport { getKeys } from \"../utils/getKeys.ts\";\nimport { LocalizedEndRoute } from \"./LocalizedEndRoute.ts\";\nimport { LocalizedSegmentRoute } from \"./LocalizedSegmentRoute.ts\";\nimport { NotLocalizedEndRoute as Route } from \"./NotLocalizedEndRoute.ts\";\nimport { NotLocalizedSegmentRoute } from \"./NotLocalizedSegmentRoute.ts\";\nimport { createRoutePath, createRoutePathSegment } from \"./createRoutePath.ts\";\n\nconst createLocalizedPaths = <\n  Locales extends LocaleType,\n  Path extends EndRoutePath | SegmentRoutePath,\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  segment: boolean,\n): Map<Locales, Path> => {\n  const localizedPaths = new Map<Locales, Path>();\n  getKeys(localizedPathsRecord).forEach((locale: Locales) => {\n    const path = localizedPathsRecord[locale];\n    if (segment) {\n      const routerPath: SegmentRoutePath = createRoutePathSegment(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    } else {\n      const routerPath: EndRoutePath = createRoutePath(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    }\n  });\n  return localizedPaths;\n};\n\nconst checkRef = <RouteRef>(ref: RouteRef): void => {\n  if (!ref) throw new Error(`Invalid ref: \"${JSON.stringify(ref)}\"`);\n};\n\nexport const createRoute = <Locales extends LocaleType, RouteRef>(\n  path: string,\n  completePath: string,\n  ref: RouteRef,\n): Route<Locales, RouteRef> => {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (path.includes(\"(.*)\")) {\n      throw new Error(\"Wildcard is not supported using regexp\");\n    }\n    checkRef(ref);\n  }\n  const routePath: EndRoutePath = createRoutePath(path, completePath);\n  return new Route(routePath, ref);\n};\n\nexport const createLocalizedRoute = <Locales extends LocaleType, RouteRef>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  ref: RouteRef,\n): LocalizedEndRoute<Locales, RouteRef> => {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== \"production\") checkRef(ref);\n  const localizedPaths = createLocalizedPaths<Locales, EndRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    false,\n  );\n  return new LocalizedEndRoute(localizedPaths, ref);\n};\n\nexport const createSegmentRoute = <Locales extends LocaleType, RouteRef>(\n  path: string,\n  completePath: string,\n): NotLocalizedSegmentRoute<Locales, RouteRef> => {\n  const routePath = createRoutePathSegment(path, completePath);\n  return new NotLocalizedSegmentRoute(routePath);\n};\n\nexport const createLocalizedSegmentRoute = <\n  Locales extends LocaleType,\n  RouteRef,\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n): LocalizedSegmentRoute<Locales, RouteRef> => {\n  const localizedPaths = createLocalizedPaths<Locales, SegmentRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    true,\n  );\n  return new LocalizedSegmentRoute(localizedPaths);\n};\n","import {\n  createLocalizedRoute,\n  createLocalizedSegmentRoute,\n  createRoute,\n  createSegmentRoute,\n} from \"../routes/create.ts\";\nimport type {\n  LocalizedEndRoute,\n  LocalizedSegmentRoute,\n} from \"../routes/index.ts\";\nimport type { EndRoute, SegmentRoute } from \"../routes/interfaces.ts\";\nimport type { LocaleType, LocalizedPathsRecord } from \"../types.ts\";\nimport { getKeys } from \"../utils/getKeys.ts\";\n\nexport interface SegmentRouterBuilder<Locales extends LocaleType, RouteRef> {\n  add: (path: string, ref: RouteRef, key?: string) => void;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => void;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => void;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => void;\n  defaultRoute: (ref: RouteRef, key?: string) => void;\n}\n\nexport function createSegmentRouterBuilderCreator<\n  Locales extends LocaleType,\n  RouteRef,\n>(\n  defaultLocale: Locales | undefined,\n  addToRouteMap: (key: string, route: EndRoute<Locales, RouteRef>) => void,\n): (\n  segmentRoute: SegmentRoute<Locales, RouteRef>,\n) => SegmentRouterBuilder<Locales, RouteRef> {\n  const createSegmentRouterBuilder = (\n    segmentRoute: SegmentRoute<Locales, RouteRef>,\n  ): SegmentRouterBuilder<Locales, RouteRef> => {\n    const getCompletePath = (path: string, locale?: Locales): string =>\n      `${segmentRoute.getPath(locale).completePath}${path}`;\n\n    const getCompleteLocalizedPaths = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n    ): LocalizedPathsRecord<Locales> => {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const completeLocalizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n\n      getKeys(localizedPaths).forEach((locale: Locales) => {\n        completeLocalizedPaths[locale] = getCompletePath(\n          localizedPaths[locale],\n          locale,\n        );\n      });\n\n      return completeLocalizedPaths;\n    };\n\n    const createLocalizedPathFromSegment = (\n      segmentRoute: LocalizedSegmentRoute<Locales, RouteRef>,\n      path: string,\n    ): Record<Locales, string> => {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const localizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n      [...segmentRoute.localizedPaths.keys()].forEach((locale) => {\n        localizedPaths[locale] = path;\n      });\n      return localizedPaths;\n    };\n\n    const _createLocalizedEndRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ): LocalizedEndRoute<Locales, RouteRef> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const finalKey: string = key || completeLocalizedPaths[defaultLocale!];\n      const route = createLocalizedRoute(\n        localizedPaths,\n        completeLocalizedPaths,\n        ref,\n      );\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createEndRoute = (\n      path: string,\n      ref: RouteRef,\n      key?: string,\n    ): EndRoute<Locales, RouteRef> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedEndRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales, RouteRef>,\n            path,\n          ),\n          ref,\n          key,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createRoute(path, completePath, ref);\n      const finalKey: string = key || completePath;\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createLocalizedSegmentRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ): LocalizedSegmentRoute<Locales, RouteRef> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const route = createLocalizedSegmentRoute<Locales, RouteRef>(\n        localizedPaths,\n        completeLocalizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    const _createSegmentRoute = (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ): SegmentRoute<Locales, RouteRef> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedSegmentRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales, RouteRef>,\n            path,\n          ),\n          buildSegment,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createSegmentRoute<Locales, RouteRef>(path, completePath);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    return {\n      defaultRoute: (ref: RouteRef, key?: string): void => {\n        segmentRoute.defaultRoute = _createEndRoute(\"\", ref, key);\n      },\n\n      add: (path: string, ref: RouteRef, key?: string): void => {\n        segmentRoute.nestedRoutes.push(_createEndRoute(path, ref, key));\n      },\n\n      addLocalized: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        ref: RouteRef,\n        key?: string,\n      ): void => {\n        if (!defaultLocale) throw new Error(\"Invalid locales\");\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedEndRoute(localizedPaths, ref, key),\n        );\n      },\n\n      addSegment: (\n        path: string,\n        buildSegment: (\n          builder: SegmentRouterBuilder<Locales, RouteRef>,\n        ) => void,\n      ): void => {\n        segmentRoute.nestedRoutes.push(_createSegmentRoute(path, buildSegment));\n      },\n\n      addLocalizedSegment: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        buildSegment: (\n          builder: SegmentRouterBuilder<Locales, RouteRef>,\n        ) => void,\n      ): void => {\n        if (!defaultLocale) throw new Error(\"Invalid locales\");\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedSegmentRoute(localizedPaths, buildSegment),\n        );\n      },\n    };\n  };\n  return createSegmentRouterBuilder;\n}\n","import type { Router } from \"../router/createRouter.ts\";\nimport { createRouter } from \"../router/createRouter.ts\";\nimport {\n  createLocalizedRoute,\n  createLocalizedSegmentRoute,\n  createRoute,\n  createSegmentRoute,\n} from \"../routes/create.ts\";\nimport type { EndRoute } from \"../routes/interfaces.ts\";\nimport type {\n  LocaleType,\n  LocalizedPathsRecord,\n  RouteMap,\n  Routes,\n} from \"../types.ts\";\nimport type { SegmentRouterBuilder } from \"./createSegmentRouterBuilderCreator.ts\";\nimport { createSegmentRouterBuilderCreator } from \"./createSegmentRouterBuilderCreator.ts\";\n\nexport interface RouterBuilder<Locales extends LocaleType | never, RouteRef> {\n  add: (path: string, ref: RouteRef, key?: string) => this;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => this;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => this;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => this;\n  createRouter: () => Router<Locales, RouteRef>;\n  getRoutes: () => Routes<Locales, RouteRef>;\n}\n\nexport function createRouterBuilder<Locales extends LocaleType, RouteRef>(\n  locales?: Locales[],\n): RouterBuilder<Locales, RouteRef> {\n  const defaultLocale = locales?.[0];\n  const routes: Routes<Locales, RouteRef> = [];\n  const routeMap: RouteMap<Locales, RouteRef> = new Map<\n    string,\n    EndRoute<Locales, RouteRef>\n  >();\n\n  const addToRouteMap = (\n    key: string,\n    route: EndRoute<Locales, RouteRef>,\n  ): void => {\n    if (routeMap.has(key)) throw new Error(`\"${key}\" is already used`);\n    routeMap.set(key, route);\n  };\n\n  const createSegmentRouterBuilder = createSegmentRouterBuilderCreator(\n    defaultLocale,\n    addToRouteMap,\n  );\n\n  const builder: RouterBuilder<Locales, RouteRef> = {\n    add: (path: string, ref: RouteRef, key?: string) => {\n      const route = createRoute(path, path, ref);\n      routes.push(route);\n      if (!key) key = path;\n      addToRouteMap(key, route);\n      return builder;\n    },\n\n    addLocalized: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ) => {\n      if (!defaultLocale) throw new Error(\"Invalid locales\");\n      const route = createLocalizedRoute(localizedPaths, localizedPaths, ref);\n      routes.push(route);\n      const finalKey: string = key || localizedPaths[defaultLocale];\n      addToRouteMap(finalKey, route);\n      return builder;\n    },\n\n    addSegment: (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ) => {\n      const route = createSegmentRoute<Locales, RouteRef>(path, path);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n      return builder;\n    },\n\n    addLocalizedSegment: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ) => {\n      if (!defaultLocale) throw new Error(\"Invalid locales\");\n      const route = createLocalizedSegmentRoute<Locales, RouteRef>(\n        localizedPaths,\n        localizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n      return builder;\n    },\n\n    getRoutes: () => routes,\n    createRouter: () => createRouter(routes, routeMap),\n  };\n  return builder;\n}\n"],"names":["Route","segmentRoute"],"mappings":"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"}