{"version":3,"file":"index-node10.es.js","sources":["../src/utils/getKeys.ts","../src/routes/createRoutePath.ts","../src/routes/NotLocalizedEndRoute.ts","../src/routes/LocalizedEndRoute.ts","../src/routes/NotLocalizedSegmentRoute.ts","../src/routes/LocalizedSegmentRoute.ts","../src/routes/create.ts","../src/router/findMatch.ts","../src/router/createRouter.ts","../src/builder/createSegmentRouterBuilderCreator.ts","../src/builder/createRouterBuilder.ts"],"sourcesContent":["export const getKeys = <T extends {}>(o: T): (keyof T)[] =>\n  Object.keys(o) as (keyof T)[];\n","import pathToRegExp, { Key } from 'path-to-regexp';\nimport { SegmentRoutePath, EndRoutePath } from '../types';\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: true,\n): SegmentRoutePath;\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: false,\n): EndRoutePath;\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: boolean,\n): SegmentRoutePath | EndRoutePath {\n  const keys: Key[] = [];\n  const regExp = pathToRegExp(segment ? `${path}/(.+)?` : path, keys, {\n    sensitive: true,\n    strict: true,\n  });\n  const namedParams = keys.map((key) => key.name).filter(Boolean);\n\n  if (segment) return { path, completePath, regExp, namedParams };\n\n  return {\n    path,\n    completePath,\n    regExp,\n    namedParams,\n    toPath: pathToRegExp.compile(completePath),\n  };\n}\n\nexport const createRoutePathSegment = (\n  path: string,\n  completePath: string,\n): SegmentRoutePath => internalCreateRoutePath(path, completePath, true);\n\nexport const createRoutePath = (\n  path: string,\n  completePath: string,\n): EndRoutePath => internalCreateRoutePath(path, completePath, false);\n","import { EndRoutePath, RouteRef } from './types';\nimport { EndRoute, NotLocalizedRoute } from './interfaces';\n\nexport default class NotLocalizedEndRoute\n  implements EndRoute, NotLocalizedRoute<EndRoutePath> {\n  path: EndRoutePath;\n\n  ref: RouteRef;\n\n  constructor(path: EndRoutePath, ref: RouteRef) {\n    this.path = path;\n    this.ref = ref;\n    // Object.freeze(this);\n  }\n\n  getPath(): EndRoutePath {\n    return this.path;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON() {\n    return this.path;\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import { LocaleType, EndRoutePath, RouteRef } from './types';\nimport { EndRoute, LocalizedRoute } from './interfaces';\n\nexport default class LocalizedEndRoute<Locales extends LocaleType>\n  implements EndRoute, LocalizedRoute<EndRoutePath, Locales> {\n  localizedPaths: Map<LocaleType, EndRoutePath>;\n\n  ref: RouteRef;\n\n  constructor(localizedPaths: Map<LocaleType, EndRoutePath>, ref: RouteRef) {\n    this.localizedPaths = localizedPaths;\n    this.ref = ref;\n    Object.freeze(this);\n  }\n\n  getPath(locale: Locales): EndRoutePath {\n    return this.localizedPaths.get(locale) as EndRoutePath;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON() {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import NotLocalizedEndRoute from './NotLocalizedEndRoute';\nimport { SegmentRoute, NotLocalizedRoute } from './interfaces';\nimport { SegmentRoutePath } from './types';\n\nexport default class NotLocalizedSegmentRoute\n  implements SegmentRoute, NotLocalizedRoute<SegmentRoutePath> {\n  path: SegmentRoutePath;\n\n  nestedRoutes: NotLocalizedRoute<any>[] = [];\n\n  defaultRoute: undefined | NotLocalizedEndRoute;\n\n  constructor(path: SegmentRoutePath) {\n    this.path = path;\n  }\n\n  freeze() {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(): SegmentRoutePath {\n    return this.path;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON() {\n    return this.path;\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import LocalizedEndRoute from './LocalizedEndRoute';\nimport { LocaleType, SegmentRoutePath } from './types';\nimport { SegmentRoute, LocalizedRoute } from './interfaces';\n\nexport default class LocalizedSegmentRoute<Locales extends LocaleType>\n  implements SegmentRoute, LocalizedRoute<SegmentRoutePath, Locales> {\n  localizedPaths: Map<Locales, SegmentRoutePath>;\n\n  nestedRoutes: LocalizedRoute<any, Locales>[] = [];\n\n  defaultRoute: undefined | LocalizedEndRoute<Locales>;\n\n  constructor(localizedPaths: Map<Locales, SegmentRoutePath>) {\n    this.localizedPaths = localizedPaths;\n  }\n\n  freeze() {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(locale: Locales): SegmentRoutePath {\n    return this.localizedPaths.get(locale) as SegmentRoutePath;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON() {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import { PRODUCTION } from 'pob-babel';\nimport {\n  LocaleType,\n  LocalizedPathsRecord,\n  EndRoutePath,\n  SegmentRoutePath,\n  RouteRef,\n} from '../types';\nimport { getKeys } from '../utils/getKeys';\nimport { createRoutePath, createRoutePathSegment } from './createRoutePath';\nimport Route from './NotLocalizedEndRoute';\nimport LocalizedEndRoute from './LocalizedEndRoute';\nimport NotLocalizedSegmentRoute from './NotLocalizedSegmentRoute';\nimport LocalizedSegmentRoute from './LocalizedSegmentRoute';\n\nconst createLocalizedPaths = <\n  Locales extends LocaleType,\n  Path extends SegmentRoutePath | EndRoutePath\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  segment: boolean,\n): Map<Locales, Path> => {\n  const localizedPaths = new Map();\n  getKeys(localizedPathsRecord).forEach((locale: Locales) => {\n    const path = localizedPathsRecord[locale];\n    if (segment) {\n      const routerPath: SegmentRoutePath = createRoutePathSegment(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath);\n    } else {\n      const routerPath: EndRoutePath = createRoutePath(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath);\n    }\n  });\n  return localizedPaths;\n};\n\nconst checkRef = (ref: RouteRef): void => {\n  if (!ref) throw new Error(`Invalid ref: \"${ref}\"`);\n};\n\nexport const createRoute = (\n  path: string,\n  completePath: string,\n  ref: RouteRef,\n): Route => {\n  /* istanbul ignore if */\n  if (!PRODUCTION) checkRef(ref);\n  const routePath: EndRoutePath = createRoutePath(path, completePath);\n  return new Route(routePath, ref);\n};\n\nexport const createLocalizedRoute = <Locales extends LocaleType>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  ref: RouteRef,\n): LocalizedEndRoute<Locales> => {\n  /* istanbul ignore if */\n  if (!PRODUCTION) checkRef(ref);\n  const localizedPaths = createLocalizedPaths<Locales, EndRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    false,\n  );\n  return new LocalizedEndRoute(localizedPaths, ref);\n};\n\nexport const createSegmentRoute = (\n  path: string,\n  completePath: string,\n): NotLocalizedSegmentRoute => {\n  const routePath = createRoutePathSegment(path, completePath);\n  return new NotLocalizedSegmentRoute(routePath);\n};\n\nexport const createLocalizedSegmentRoute = <Locales extends LocaleType>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n): LocalizedSegmentRoute<Locales> => {\n  const localizedPaths = createLocalizedPaths<Locales, SegmentRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    true,\n  );\n  return new LocalizedSegmentRoute(localizedPaths);\n};\n","import { PRODUCTION } from 'pob-babel';\nimport Logger from 'nightingale-logger';\nimport {\n  Routes,\n  LocaleType,\n  RoutePathInterface,\n  RouteRef,\n  SegmentRoutePath,\n  EndRoutePath,\n} from '../types';\nimport { EndRoute, Route, SegmentRoute } from '../routes/interfaces';\n\nexport interface RouteMatch<Locales extends LocaleType | never> {\n  namedParams: undefined | Map<string, string>;\n  otherParams: undefined | string[];\n  path: string;\n  ref: RouteRef;\n  route: Route<any, Locales>;\n  routePath: SegmentRoutePath | EndRoutePath;\n}\n\nconst logger = !PRODUCTION\n  ? new Logger('router-segments:findMatch')\n  : undefined;\n\nconst parseOtherParams = (wildcard: string) =>\n  wildcard ? wildcard.split('/') : [];\n\nconst internalFindMatch = <Locales extends LocaleType>(\n  path: string,\n  completePath: string,\n  routes: Routes<Locales>,\n  locale: Locales = 'en' as Locales,\n  namedParams?: Map<string | number, string>,\n): null | RouteMatch<Locales> => {\n  let result = null;\n\n  routes.some((route): boolean => {\n    const routePath: RoutePathInterface = route.getPath(locale);\n\n    if (!PRODUCTION && !routePath) {\n      throw new Error(`Unknown localized route for locale ${locale}`);\n    }\n\n    /* istanbul ignore next */\n    if (!PRODUCTION && logger) {\n      logger.debug(`trying ${routePath.regExp}`);\n    }\n\n    const match = routePath.regExp.exec(path);\n    if (!match) return false;\n\n    match.shift(); // remove m[0], === path;\n\n    let groupCount = match.length;\n    let group = 0;\n\n    if (routePath.namedParams.length !== 0) {\n      // set params\n      if (!namedParams) namedParams = new Map();\n\n      routePath.namedParams.forEach((paramName: string | number) => {\n        (namedParams as Map<string | number, string>).set(\n          paramName,\n          match[group++],\n        );\n      });\n    }\n\n    if (route.isSegment()) {\n      const segment = route as SegmentRoute;\n      const restOfThePath = match[--groupCount];\n\n      if (restOfThePath) {\n        result = internalFindMatch(\n          `/${restOfThePath}`,\n          completePath,\n          segment.nestedRoutes,\n          locale,\n          namedParams,\n        );\n\n        return result !== null;\n      }\n\n      if (!segment.defaultRoute) {\n        return false;\n      }\n\n      route = segment.defaultRoute;\n    }\n\n    const endRoute = route as EndRoute;\n\n    const otherParams =\n      group + 1 !== groupCount ? undefined : parseOtherParams(match[group]);\n\n    result = Object.freeze({\n      ref: endRoute.ref,\n      path: completePath,\n      route: endRoute,\n      routePath,\n      namedParams,\n      otherParams,\n    });\n\n    return true;\n  });\n\n  return result;\n};\n\nexport default function findMatch<Locales extends LocaleType>(\n  path: string,\n  routes: Routes<Locales>,\n  locale?: Locales,\n): null | RouteMatch<Locales> {\n  return internalFindMatch(path, path, routes, locale);\n}\n","import { Routes, RouteMap, LocaleType } from '../types';\nimport { EndRoute } from '../routes/interfaces';\nimport findMatch, { RouteMatch } from './findMatch';\n\nexport interface Router<Locales extends LocaleType | never> {\n  get(key: string): EndRoute;\n  find(path: string, locale?: Locales): null | RouteMatch<Locales>;\n  toLocalizedPath(locale: Locales, key: string, args?: any): string;\n  toPath(key: string, args?: any): string;\n}\n\nexport default function createRouter<Locales extends LocaleType | never>(\n  routes: Routes<Locales>,\n  routeMap: RouteMap<Locales>,\n): Router<Locales> {\n  const getRequiredRoute = (routeKey: string): EndRoute => {\n    const route = routeMap.get(routeKey);\n    if (!route) throw new Error(`No route named \"${routeKey}\"`);\n    return route;\n  };\n\n  return {\n    get: getRequiredRoute,\n    find: (path: string, locale?: Locales): null | RouteMatch<Locales> =>\n      findMatch(path, routes, locale),\n    toPath: (key: string, args?: any): string =>\n      getRequiredRoute(key).getPath().toPath(args),\n    toLocalizedPath: (locale: Locales, key: string, args?: any): string =>\n      getRequiredRoute(key).getPath(locale).toPath(args),\n  };\n}\n","import { LocalizedPathsRecord, RouteRef, LocaleType } from '../types';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\nimport { LocalizedSegmentRoute, LocalizedEndRoute } from '../routes';\nimport { EndRoute, SegmentRoute } from '../routes/interfaces';\nimport { getKeys } from '../utils/getKeys';\n\nexport interface SegmentRouterBuilder<Locales extends LocaleType> {\n  add(path: string, ref: RouteRef, key?: string): void;\n  addLocalized(\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ): void;\n  addLocalizedSegment(\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ): void;\n  addSegment(\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ): void;\n  defaultRoute(ref: RouteRef, key?: string): void;\n}\n\nexport default function createSegmentRouterBuilderCreator<\n  Locales extends LocaleType\n>(\n  defaultLocale: undefined | Locales,\n  addToRouteMap: (key: string, route: EndRoute<Locales>) => void,\n): (segmentRoute: SegmentRoute<Locales>) => SegmentRouterBuilder<Locales> {\n  const createSegmentRouterBuilder = (\n    segmentRoute: SegmentRoute<Locales>,\n  ): SegmentRouterBuilder<Locales> => {\n    const getCompletePath = (path: string, locale?: Locales): string =>\n      `${segmentRoute.getPath(locale).completePath}${path}`;\n\n    const getCompleteLocalizedPaths = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n    ): LocalizedPathsRecord<Locales> => {\n      const completeLocalizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n\n      getKeys(localizedPaths).forEach((locale: Locales) => {\n        completeLocalizedPaths[locale] = getCompletePath(\n          localizedPaths[locale],\n          locale,\n        );\n      });\n\n      return completeLocalizedPaths;\n    };\n\n    const createLocalizedPathFromSegment = (\n      segmentRoute: LocalizedSegmentRoute<Locales>,\n      path: string,\n    ): Record<Locales, string> => {\n      const localizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n      [...segmentRoute.localizedPaths.keys()].forEach((locale) => {\n        localizedPaths[locale] = path;\n      });\n      return localizedPaths;\n    };\n\n    const _createLocalizedEndRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ): LocalizedEndRoute<Locales> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const finalKey: string =\n        key || completeLocalizedPaths[defaultLocale as Locales];\n      const route = createLocalizedRoute(\n        localizedPaths,\n        completeLocalizedPaths,\n        ref,\n      );\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createEndRoute = (\n      path: string,\n      ref: RouteRef,\n      key?: string,\n    ): EndRoute<Locales> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedEndRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales>,\n            path,\n          ),\n          ref,\n          key,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createRoute(path, completePath, ref);\n      const finalKey: string = key || completePath;\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createLocalizedSegmentRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): LocalizedSegmentRoute<Locales> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const route = createLocalizedSegmentRoute(\n        localizedPaths,\n        completeLocalizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    const _createSegmentRoute = (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): SegmentRoute<Locales> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedSegmentRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales>,\n            path,\n          ),\n          buildSegment,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createSegmentRoute(path, completePath);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    return {\n      defaultRoute: (ref: RouteRef, key?: string): void => {\n        segmentRoute.defaultRoute = _createEndRoute('', ref, key);\n      },\n\n      add: (path: string, ref: RouteRef, key?: string): void => {\n        segmentRoute.nestedRoutes.push(_createEndRoute(path, ref, key));\n      },\n\n      addLocalized: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        ref: RouteRef,\n        key?: string,\n      ): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedEndRoute(localizedPaths, ref, key),\n        );\n      },\n\n      addSegment: (\n        path: string,\n        buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n      ): void => {\n        segmentRoute.nestedRoutes.push(_createSegmentRoute(path, buildSegment));\n      },\n\n      addLocalizedSegment: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n      ): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedSegmentRoute(localizedPaths, buildSegment),\n        );\n      },\n    };\n  };\n  return createSegmentRouterBuilder;\n}\n","import {\n  LocaleType,\n  LocalizedPathsRecord,\n  Routes,\n  RouteMap,\n  RouteRef,\n} from '../types';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\nimport createRouter, { Router } from '../router/createRouter';\nimport { EndRoute } from '../routes/interfaces';\nimport createSegmentRouterBuilderCreator, {\n  SegmentRouterBuilder,\n} from './createSegmentRouterBuilderCreator';\n\nexport interface RouterBuilder<Locales extends LocaleType | never> {\n  add(path: string, ref: RouteRef, key?: string): void;\n  addLocalized(\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ): void;\n  addLocalizedSegment(\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ): void;\n  addSegment(\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ): void;\n  createRouter(): Router<Locales>;\n  getRoutes(): Routes<Locales>;\n}\n\nexport default function createRouterBuilder<Locales extends LocaleType>(\n  locales?: Locales[],\n): RouterBuilder<Locales> {\n  const defaultLocale = locales?.[0];\n  const routes: Routes<Locales> = [];\n  const routeMap: RouteMap<Locales> = new Map();\n\n  const addToRouteMap = (key: string, route: EndRoute<Locales>) => {\n    if (routeMap.has(key)) throw new Error(`\"${key}\" is already used`);\n    routeMap.set(key, route);\n  };\n\n  const createSegmentRouterBuilder = createSegmentRouterBuilderCreator(\n    defaultLocale,\n    addToRouteMap,\n  );\n\n  return {\n    add: (path: string, ref: RouteRef, key?: string): void => {\n      const route = createRoute(path, path, ref);\n      routes.push(route);\n      if (!key) key = path;\n      addToRouteMap(key, route);\n    },\n\n    addLocalized: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ): void => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedRoute(localizedPaths, localizedPaths, ref);\n      routes.push(route);\n      const finalKey: string = key || localizedPaths[defaultLocale];\n      addToRouteMap(finalKey, route);\n    },\n\n    addSegment: (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): void => {\n      const route = createSegmentRoute(path, path);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n    },\n\n    addLocalizedSegment: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): void => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedSegmentRoute(localizedPaths, localizedPaths);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n    },\n\n    getRoutes: () => routes,\n    createRouter: () => createRouter(routes, routeMap),\n  };\n}\n"],"names":["getKeys","o","Object","keys","internalCreateRoutePath","path","completePath","segment","regExp","pathToRegExp","sensitive","strict","namedParams","map","key","name","filter","Boolean","toPath","compile","createRoutePathSegment","createRoutePath","NotLocalizedEndRoute","constructor","ref","getPath","isSegment","isLocalized","toJSON","toString","JSON","stringify","LocalizedEndRoute","localizedPaths","freeze","locale","get","entries","NotLocalizedSegmentRoute","nestedRoutes","LocalizedSegmentRoute","createLocalizedPaths","localizedPathsRecord","completeLocalizedPathsRecord","Map","forEach","routerPath","set","createRoute","routePath","Route","createLocalizedRoute","createSegmentRoute","createLocalizedSegmentRoute","parseOtherParams","wildcard","split","internalFindMatch","routes","result","some","route","match","exec","shift","groupCount","length","group","paramName","restOfThePath","defaultRoute","endRoute","otherParams","undefined","findMatch","createRouter","routeMap","getRequiredRoute","routeKey","Error","find","args","toLocalizedPath","createSegmentRouterBuilderCreator","defaultLocale","addToRouteMap","createSegmentRouterBuilder","segmentRoute","getCompletePath","getCompleteLocalizedPaths","completeLocalizedPaths","createLocalizedPathFromSegment","_createLocalizedEndRoute","finalKey","_createEndRoute","_createLocalizedSegmentRoute","buildSegment","_createSegmentRoute","add","push","addLocalized","addSegment","addLocalizedSegment","createRouterBuilder","locales","has","getRoutes"],"mappings":"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"}