{"version":3,"file":"index-node18.mjs","sources":["../src/router/findMatch.ts","../src/router/createRouter.ts","../src/utils/getKeys.ts","../src/routes/LocalizedEndRoute.ts","../src/routes/LocalizedSegmentRoute.ts","../src/routes/NotLocalizedEndRoute.ts","../src/routes/NotLocalizedSegmentRoute.ts","../src/routes/createRoutePath.ts","../src/routes/create.ts","../src/builder/createSegmentRouterBuilderCreator.ts","../src/builder/createRouterBuilder.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport { IS_DEV } from 'pob-babel';\nimport { Logger } from 'nightingale-logger';\nimport type { EndRoute, Route, SegmentRoute } from '../routes/interfaces';\nimport type {\n  LocaleType,\n  RoutePathInterface,\n  RouteRef,\n  SegmentRoutePath,\n  EndRoutePath,\n} from '../types';\n\nexport interface RouteMatch<Locales extends LocaleType | never = any> {\n  namedParams: Map<string, string> | undefined;\n  otherParams: string[] | undefined;\n  path: string;\n  ref: RouteRef;\n  route: Route<any, Locales>;\n  routePath: EndRoutePath | SegmentRoutePath;\n}\n\nconst logger = IS_DEV ? new Logger('router-segments:findMatch') : undefined;\n\nconst parseOtherParams = (wildcard: string): string[] =>\n  wildcard ? wildcard.split('/') : [];\n\nconst internalFindMatch = <Locales extends LocaleType>(\n  path: string,\n  completePath: string,\n  routes: Route<RoutePathInterface, Locales>[],\n  locale: Locales = 'en' as Locales,\n  namedParams?: Map<number | string, string>,\n): RouteMatch<Locales> | null => {\n  let result = null;\n\n  routes.some((route): boolean => {\n    const routePath: RoutePathInterface = route.getPath(locale);\n    const isDev = IS_DEV;\n\n    if (isDev && !routePath) {\n      throw new Error(`Unknown localized route for locale ${locale}`);\n    }\n\n    /* istanbul ignore next */\n    if (isDev && logger) {\n      logger.debug(`trying ${routePath.regExp.toString()}`);\n    }\n\n    const match = routePath.regExp.exec(path);\n    // logger.info('trytomatch', { path, regExp: routePath.regExp, match });\n    if (!match) return false;\n\n    match.shift(); // remove m[0], === path;\n\n    let groupCount = match.length;\n    let group = 0;\n\n    if (routePath.namedParams.length > 0) {\n      // set params\n      if (!namedParams) namedParams = new Map();\n\n      routePath.namedParams.forEach((paramName: number | string) => {\n        namedParams!.set(paramName, match[group++]);\n      });\n    }\n\n    if (route.isSegment()) {\n      const segment = route as SegmentRoute;\n      const restOfThePath = match[--groupCount];\n\n      if (restOfThePath) {\n        result = internalFindMatch(\n          `/${restOfThePath}`,\n          completePath,\n          segment.nestedRoutes,\n          locale,\n          namedParams,\n        );\n\n        return result !== null;\n      }\n\n      if (!segment.defaultRoute) {\n        return false;\n      }\n\n      route = segment.defaultRoute;\n    }\n\n    const endRoute = route as EndRoute;\n\n    const otherParams =\n      group + 1 !== groupCount ? undefined : parseOtherParams(match[group]);\n\n    result = Object.freeze({\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      ref: endRoute.ref,\n      path: completePath,\n      route: endRoute,\n      routePath,\n      namedParams,\n      otherParams,\n    });\n\n    return true;\n  });\n\n  return result;\n};\n\nexport function findMatch<Locales extends LocaleType>(\n  path: string,\n  routes: Route<RoutePathInterface, Locales>[],\n  locale?: Locales,\n): RouteMatch<Locales> | null {\n  return internalFindMatch(path, path, routes, locale);\n}\n","import type { EndRoute } from '../routes/interfaces';\nimport type { Routes, RouteMap, LocaleType } from '../types';\nimport type { RouteMatch } from './findMatch';\nimport { findMatch } from './findMatch';\n\nexport interface Router<Locales extends LocaleType | never = any> {\n  get: (key: string) => EndRoute<Locales>;\n  find: (path: string, locale?: Locales) => RouteMatch<Locales> | null;\n  toLocalizedPath: (locale: Locales, key: string, args?: any) => string;\n  toPath: (key: string, args?: any) => string;\n}\n\nexport function createRouter<Locales extends LocaleType | never>(\n  routes: Routes<Locales>,\n  routeMap: RouteMap<Locales>,\n): Router<Locales> {\n  const getRequiredRoute = (routeKey: string): EndRoute<Locales> => {\n    const route = routeMap.get(routeKey);\n    if (!route) throw new Error(`No route named \"${routeKey}\"`);\n    return route;\n  };\n\n  return {\n    get: getRequiredRoute,\n    find: (path: string, locale?: Locales): RouteMatch<Locales> | null =>\n      findMatch(path, routes, locale),\n    toPath: (key: string, args?: Record<string, any>): string =>\n      getRequiredRoute(key).getPath().toPath(args),\n    toLocalizedPath: (\n      locale: Locales,\n      key: string,\n      args?: Record<string, any>,\n    ): string => getRequiredRoute(key).getPath(locale).toPath(args),\n  };\n}\n","export const getKeys = <T extends Record<string, unknown>>(o: T): (keyof T)[] =>\n  Object.keys(o) as (keyof T)[];\n","import type { EndRoute, LocalizedRoute } from './interfaces';\nimport type { LocaleType, EndRoutePath, RouteRef } from './types';\n\nexport class LocalizedEndRoute<Locales extends LocaleType>\n  implements EndRoute<Locales>, LocalizedRoute<EndRoutePath, Locales>\n{\n  localizedPaths: Map<LocaleType, EndRoutePath>;\n\n  ref: RouteRef;\n\n  constructor(localizedPaths: Map<LocaleType, EndRoutePath>, ref: RouteRef) {\n    this.localizedPaths = localizedPaths;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this.ref = ref;\n    Object.freeze(this);\n  }\n\n  getPath(locale?: Locales): EndRoutePath {\n    if (!locale) throw new Error('Missing locale');\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { LocalizedEndRoute } from './LocalizedEndRoute';\nimport type { SegmentRoute, LocalizedRoute } from './interfaces';\nimport type { LocaleType, SegmentRoutePath } from './types';\n\nexport class LocalizedSegmentRoute<Locales extends LocaleType>\n  implements SegmentRoute<Locales>, LocalizedRoute<SegmentRoutePath, Locales>\n{\n  localizedPaths: Map<Locales, SegmentRoutePath>;\n\n  nestedRoutes: LocalizedRoute<any, Locales>[] = [];\n\n  defaultRoute: LocalizedEndRoute<Locales> | undefined;\n\n  constructor(localizedPaths: Map<Locales, SegmentRoutePath>) {\n    this.localizedPaths = localizedPaths;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(locale?: Locales): SegmentRoutePath {\n    if (!locale) throw new Error('Missing locale');\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { EndRoute, NotLocalizedRoute } from './interfaces';\nimport type { EndRoutePath, LocaleType, RouteRef } from './types';\n\nexport class NotLocalizedEndRoute<Locales extends LocaleType = LocaleType>\n  implements EndRoute<Locales>, NotLocalizedRoute<EndRoutePath, Locales>\n{\n  path: EndRoutePath;\n\n  ref: RouteRef;\n\n  constructor(path: EndRoutePath, ref: RouteRef) {\n    this.path = path;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this.ref = ref;\n    // Object.freeze(this);\n  }\n\n  getPath(): EndRoutePath {\n    return this.path;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { NotLocalizedEndRoute } from './NotLocalizedEndRoute';\nimport type { SegmentRoute, NotLocalizedRoute } from './interfaces';\nimport type { LocaleType, SegmentRoutePath } from './types';\n\nexport class NotLocalizedSegmentRoute<Locales extends LocaleType = LocaleType>\n  implements\n    SegmentRoute<Locales>,\n    NotLocalizedRoute<SegmentRoutePath, Locales>\n{\n  path: SegmentRoutePath;\n\n  nestedRoutes: NotLocalizedRoute<any, Locales>[] = [];\n\n  defaultRoute: NotLocalizedEndRoute | undefined;\n\n  constructor(path: SegmentRoutePath) {\n    this.path = path;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(): SegmentRoutePath {\n    return this.path;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { Key } from 'path-to-regexp';\nimport { pathToRegexp, compile } from 'path-to-regexp';\nimport type { SegmentRoutePath, EndRoutePath } from '../types';\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: true,\n): SegmentRoutePath;\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: false,\n): EndRoutePath;\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: boolean,\n): EndRoutePath | SegmentRoutePath {\n  const keys: Key[] = [];\n  const regExp = pathToRegexp(segment ? `${path}/(.*)?` : path, keys, {\n    sensitive: true,\n    strict: true,\n  });\n  const namedParams = keys.map((key) => key.name).filter(Boolean);\n\n  if (segment) return { path, completePath, regExp, namedParams };\n\n  return {\n    path,\n    completePath,\n    regExp,\n    namedParams,\n    toPath: compile(completePath),\n  };\n}\n\nexport const createRoutePathSegment = (\n  path: string,\n  completePath: string,\n): SegmentRoutePath => internalCreateRoutePath(path, completePath, true);\n\nexport const createRoutePath = (\n  path: string,\n  completePath: string,\n): EndRoutePath => internalCreateRoutePath(path, completePath, false);\n","import { IS_DEV } from 'pob-babel';\nimport type {\n  LocaleType,\n  LocalizedPathsRecord,\n  EndRoutePath,\n  SegmentRoutePath,\n  RouteRef,\n} from '../types';\nimport { getKeys } from '../utils/getKeys';\nimport { LocalizedEndRoute } from './LocalizedEndRoute';\nimport { LocalizedSegmentRoute } from './LocalizedSegmentRoute';\nimport { NotLocalizedEndRoute as Route } from './NotLocalizedEndRoute';\nimport { NotLocalizedSegmentRoute } from './NotLocalizedSegmentRoute';\nimport { createRoutePath, createRoutePathSegment } from './createRoutePath';\n\nconst createLocalizedPaths = <\n  Locales extends LocaleType,\n  Path extends EndRoutePath | SegmentRoutePath,\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  segment: boolean,\n): Map<Locales, Path> => {\n  const localizedPaths = new Map<Locales, Path>();\n  getKeys(localizedPathsRecord).forEach((locale: Locales) => {\n    const path = localizedPathsRecord[locale];\n    if (segment) {\n      const routerPath: SegmentRoutePath = createRoutePathSegment(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    } else {\n      const routerPath: EndRoutePath = createRoutePath(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    }\n  });\n  return localizedPaths;\n};\n\nconst checkRef = (ref: RouteRef): void => {\n  if (!ref) throw new Error(`Invalid ref: \"${JSON.stringify(ref)}\"`);\n};\n\nexport const createRoute = (\n  path: string,\n  completePath: string,\n  ref: RouteRef,\n): Route => {\n  /* istanbul ignore if */\n  if (IS_DEV) checkRef(ref);\n  const routePath: EndRoutePath = createRoutePath(path, completePath);\n  return new Route(routePath, ref);\n};\n\nexport const createLocalizedRoute = <Locales extends LocaleType>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  ref: RouteRef,\n): LocalizedEndRoute<Locales> => {\n  /* istanbul ignore if */\n  if (IS_DEV) checkRef(ref);\n  const localizedPaths = createLocalizedPaths<Locales, EndRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    false,\n  );\n  return new LocalizedEndRoute(localizedPaths, ref);\n};\n\nexport const createSegmentRoute = (\n  path: string,\n  completePath: string,\n): NotLocalizedSegmentRoute => {\n  const routePath = createRoutePathSegment(path, completePath);\n  return new NotLocalizedSegmentRoute(routePath);\n};\n\nexport const createLocalizedSegmentRoute = <Locales extends LocaleType>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n): LocalizedSegmentRoute<Locales> => {\n  const localizedPaths = createLocalizedPaths<Locales, SegmentRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    true,\n  );\n  return new LocalizedSegmentRoute(localizedPaths);\n};\n","import type { LocalizedSegmentRoute, LocalizedEndRoute } from '../routes';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\nimport type { EndRoute, SegmentRoute } from '../routes/interfaces';\nimport type { LocalizedPathsRecord, RouteRef, LocaleType } from '../types';\nimport { getKeys } from '../utils/getKeys';\n\nexport interface SegmentRouterBuilder<Locales extends LocaleType> {\n  add: (path: string, ref: RouteRef, key?: string) => void;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => void;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ) => void;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ) => void;\n  defaultRoute: (ref: RouteRef, key?: string) => void;\n}\n\nexport function createSegmentRouterBuilderCreator<Locales extends LocaleType>(\n  defaultLocale: Locales | undefined,\n  addToRouteMap: (key: string, route: EndRoute<Locales>) => void,\n): (segmentRoute: SegmentRoute<Locales>) => SegmentRouterBuilder<Locales> {\n  const createSegmentRouterBuilder = (\n    segmentRoute: SegmentRoute<Locales>,\n  ): SegmentRouterBuilder<Locales> => {\n    const getCompletePath = (path: string, locale?: Locales): string =>\n      `${segmentRoute.getPath(locale).completePath}${path}`;\n\n    const getCompleteLocalizedPaths = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n    ): LocalizedPathsRecord<Locales> => {\n      const completeLocalizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n\n      getKeys(localizedPaths).forEach((locale: Locales) => {\n        completeLocalizedPaths[locale] = getCompletePath(\n          localizedPaths[locale],\n          locale,\n        );\n      });\n\n      return completeLocalizedPaths;\n    };\n\n    const createLocalizedPathFromSegment = (\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      segmentRoute: LocalizedSegmentRoute<Locales>,\n      path: string,\n    ): Record<Locales, string> => {\n      const localizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n      [...segmentRoute.localizedPaths.keys()].forEach((locale) => {\n        localizedPaths[locale] = path;\n      });\n      return localizedPaths;\n    };\n\n    const _createLocalizedEndRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ): LocalizedEndRoute<Locales> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const finalKey: string = key || completeLocalizedPaths[defaultLocale!];\n      const route = createLocalizedRoute(\n        localizedPaths,\n        completeLocalizedPaths,\n        ref,\n      );\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createEndRoute = (\n      path: string,\n      ref: RouteRef,\n      key?: string,\n    ): EndRoute<Locales> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedEndRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales>,\n            path,\n          ),\n          ref,\n          key,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createRoute(path, completePath, ref);\n      const finalKey: string = key || completePath;\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createLocalizedSegmentRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): LocalizedSegmentRoute<Locales> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const route = createLocalizedSegmentRoute(\n        localizedPaths,\n        completeLocalizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    const _createSegmentRoute = (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): SegmentRoute<Locales> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedSegmentRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales>,\n            path,\n          ),\n          buildSegment,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createSegmentRoute(path, completePath);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    return {\n      defaultRoute: (ref: RouteRef, key?: string): void => {\n        segmentRoute.defaultRoute = _createEndRoute('', ref, key);\n      },\n\n      add: (path: string, ref: RouteRef, key?: string): void => {\n        segmentRoute.nestedRoutes.push(_createEndRoute(path, ref, key));\n      },\n\n      addLocalized: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        ref: RouteRef,\n        key?: string,\n      ): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedEndRoute(localizedPaths, ref, key),\n        );\n      },\n\n      addSegment: (\n        path: string,\n        buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n      ): void => {\n        segmentRoute.nestedRoutes.push(_createSegmentRoute(path, buildSegment));\n      },\n\n      addLocalizedSegment: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n      ): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedSegmentRoute(localizedPaths, buildSegment),\n        );\n      },\n    };\n  };\n  return createSegmentRouterBuilder;\n}\n","import type { Router } from '../router/createRouter';\nimport { createRouter } from '../router/createRouter';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\nimport type { EndRoute } from '../routes/interfaces';\nimport type {\n  LocaleType,\n  LocalizedPathsRecord,\n  Routes,\n  RouteMap,\n  RouteRef,\n} from '../types';\nimport type { SegmentRouterBuilder } from './createSegmentRouterBuilderCreator';\nimport { createSegmentRouterBuilderCreator } from './createSegmentRouterBuilderCreator';\n\nexport interface RouterBuilder<Locales extends LocaleType | never> {\n  add: (path: string, ref: RouteRef, key?: string) => void;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => void;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ) => void;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n  ) => void;\n  createRouter: () => Router<Locales>;\n  getRoutes: () => Routes<Locales>;\n}\n\nexport function createRouterBuilder<Locales extends LocaleType>(\n  locales?: Locales[],\n): RouterBuilder<Locales> {\n  const defaultLocale = locales?.[0];\n  const routes: Routes<Locales> = [];\n  const routeMap: RouteMap<Locales> = new Map<string, EndRoute<Locales>>();\n\n  const addToRouteMap = (key: string, route: EndRoute<Locales>): void => {\n    if (routeMap.has(key)) throw new Error(`\"${key}\" is already used`);\n    routeMap.set(key, route);\n  };\n\n  const createSegmentRouterBuilder = createSegmentRouterBuilderCreator(\n    defaultLocale,\n    addToRouteMap,\n  );\n\n  return {\n    add: (path: string, ref: RouteRef, key?: string): void => {\n      const route = createRoute(path, path, ref);\n      routes.push(route);\n      if (!key) key = path;\n      addToRouteMap(key, route);\n    },\n\n    addLocalized: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ): void => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedRoute(localizedPaths, localizedPaths, ref);\n      routes.push(route);\n      const finalKey: string = key || localizedPaths[defaultLocale];\n      addToRouteMap(finalKey, route);\n    },\n\n    addSegment: (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): void => {\n      const route = createSegmentRoute(path, path);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n    },\n\n    addLocalizedSegment: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales>) => void,\n    ): void => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedSegmentRoute(localizedPaths, localizedPaths);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n    },\n\n    getRoutes: () => routes,\n    createRouter: () => createRouter(routes, routeMap),\n  };\n}\n"],"names":["logger","process","env","NODE_ENV","Logger","undefined","parseOtherParams","wildcard","split","internalFindMatch","path","completePath","routes","locale","namedParams","result","some","route","routePath","getPath","isDev","Error","debug","regExp","toString","match","exec","shift","groupCount","length","group","Map","forEach","paramName","set","isSegment","segment","restOfThePath","nestedRoutes","defaultRoute","endRoute","otherParams","Object","freeze","ref","findMatch","createRouter","routeMap","getRequiredRoute","routeKey","get","find","toPath","key","args","toLocalizedPath","getKeys","o","keys","LocalizedEndRoute","constructor","localizedPaths","isLocalized","toJSON","entries","JSON","stringify","LocalizedSegmentRoute","NotLocalizedEndRoute","NotLocalizedSegmentRoute","internalCreateRoutePath","pathToRegexp","sensitive","strict","map","name","filter","Boolean","compile","createRoutePathSegment","createRoutePath","createLocalizedPaths","localizedPathsRecord","completeLocalizedPathsRecord","routerPath","checkRef","createRoute","Route","createLocalizedRoute","createSegmentRoute","createLocalizedSegmentRoute","createSegmentRouterBuilderCreator","defaultLocale","addToRouteMap","createSegmentRouterBuilder","segmentRoute","getCompletePath","getCompleteLocalizedPaths","completeLocalizedPaths","createLocalizedPathFromSegment","_createLocalizedEndRoute","finalKey","_createEndRoute","_createLocalizedSegmentRoute","buildSegment","_createSegmentRoute","add","push","addLocalized","addSegment","addLocalizedSegment","createRouterBuilder","locales","has","getRoutes"],"mappings":"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"}