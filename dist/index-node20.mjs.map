{"version":3,"file":"index-node20.mjs","sources":["../src/router/findMatch.ts","../src/router/createRouter.ts","../src/utils/getKeys.ts","../src/routes/LocalizedEndRoute.ts","../src/routes/LocalizedSegmentRoute.ts","../src/routes/NotLocalizedEndRoute.ts","../src/routes/NotLocalizedSegmentRoute.ts","../src/routes/createRoutePath.ts","../src/routes/create.ts","../src/builder/createSegmentRouterBuilderCreator.ts","../src/builder/createRouterBuilder.ts"],"sourcesContent":["/* eslint-disable complexity */\nimport { Logger } from \"nightingale-logger\";\nimport type { EndRoute, Route, SegmentRoute } from \"../routes/interfaces\";\nimport type {\n  LocaleType,\n  RoutePathInterface,\n  SegmentRoutePath,\n  EndRoutePath,\n} from \"../types\";\n\nexport interface RouteMatch<Locales extends LocaleType | never, RouteRef> {\n  namedParams: Map<string, string> | undefined;\n  otherParams: string[] | undefined;\n  path: string;\n  ref: RouteRef;\n  route: Route<any, Locales, RouteRef>;\n  routePath: EndRoutePath | SegmentRoutePath;\n}\n\nconst logger =\n  process.env.NODE_ENV !== \"production\"\n    ? new Logger(\"router-segments:findMatch\")\n    : undefined;\n\nconst parseOtherParams = (wildcard: string): string[] =>\n  wildcard ? wildcard.split(\"/\") : [];\n\ninterface InternalFindMatchParams<Locales extends LocaleType, RouteRef> {\n  path: string;\n  completePath: string;\n  routes: Route<RoutePathInterface, Locales, RouteRef>[];\n  locale?: Locales;\n  namedParams?: Map<number | string, string>;\n}\n\nconst internalFindMatch = <Locales extends LocaleType, RouteRef>({\n  path,\n  completePath,\n  routes,\n  locale = \"en\" as Locales,\n  namedParams,\n}: InternalFindMatchParams<Locales, RouteRef>): RouteMatch<\n  Locales,\n  RouteRef\n> | null => {\n  let result = null;\n\n  routes.some((route): boolean => {\n    const routePath: RoutePathInterface = route.getPath(locale);\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\" && !routePath) {\n      throw new Error(`Unknown localized route for locale ${locale}`);\n    }\n\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== \"production\" && logger) {\n      logger.debug(`trying ${routePath.regExp.toString()}`);\n    }\n\n    const match = routePath.regExp.exec(path);\n    // logger.info('trytomatch', { path, regExp: routePath.regExp, match });\n    if (!match) return false;\n\n    match.shift(); // remove m[0], === path;\n\n    let groupCount = match.length;\n    let group = 0;\n\n    if (routePath.namedParams.length > 0) {\n      // set params\n      if (!namedParams) namedParams = new Map();\n\n      routePath.namedParams.forEach((paramName: number | string) => {\n        namedParams!.set(paramName, match[group++]);\n      });\n    }\n\n    if (route.isSegment()) {\n      const segment = route as SegmentRoute<Locales, RouteRef>;\n      const restOfThePath = match[--groupCount];\n\n      if (restOfThePath) {\n        result = internalFindMatch({\n          path: `/${restOfThePath}`,\n          completePath,\n          routes: segment.nestedRoutes,\n          locale,\n          namedParams,\n        });\n\n        return result !== null;\n      }\n\n      if (!segment.defaultRoute) {\n        return false;\n      }\n\n      route = segment.defaultRoute;\n    }\n\n    const endRoute = route as EndRoute<Locales, RouteRef>;\n\n    const otherParams =\n      group + 1 !== groupCount ? undefined : parseOtherParams(match[group]);\n\n    result = Object.freeze({\n      ref: endRoute.ref,\n      path: completePath,\n      route: endRoute,\n      routePath,\n      namedParams,\n      otherParams,\n    });\n\n    return true;\n  });\n\n  return result;\n};\n\nexport function findMatch<Locales extends LocaleType, RouteRef>(\n  path: string,\n  routes: Route<RoutePathInterface, Locales, RouteRef>[],\n  locale?: Locales,\n): RouteMatch<Locales, RouteRef> | null {\n  return internalFindMatch({ path, completePath: path, routes, locale });\n}\n","import type { EndRoute } from \"../routes/interfaces\";\nimport type { Routes, RouteMap, LocaleType } from \"../types\";\nimport type { RouteMatch } from \"./findMatch\";\nimport { findMatch } from \"./findMatch\";\n\nexport interface Router<Locales extends LocaleType | never, RouteRef> {\n  get: (key: string) => EndRoute<Locales, RouteRef>;\n  find: (\n    path: string,\n    locale?: Locales,\n  ) => RouteMatch<Locales, RouteRef> | null;\n  toLocalizedPath: (locale: Locales, key: string, args?: any) => string;\n  toPath: (key: string, args?: any) => string;\n}\n\nexport function createRouter<Locales extends LocaleType | never, RouteRef>(\n  routes: Routes<Locales, RouteRef>,\n  routeMap: RouteMap<Locales, RouteRef>,\n): Router<Locales, RouteRef> {\n  const getRequiredRoute = (routeKey: string): EndRoute<Locales, RouteRef> => {\n    const route = routeMap.get(routeKey);\n    if (!route) throw new Error(`No route named \"${routeKey}\"`);\n    return route;\n  };\n\n  return {\n    get: getRequiredRoute,\n    find: (\n      path: string,\n      locale?: Locales,\n    ): RouteMatch<Locales, RouteRef> | null => findMatch(path, routes, locale),\n    toPath: (key: string, args?: Record<string, any>): string =>\n      getRequiredRoute(key).getPath().toPath(args),\n    toLocalizedPath: (\n      locale: Locales,\n      key: string,\n      args?: Record<string, any>,\n    ): string => getRequiredRoute(key).getPath(locale).toPath(args),\n  };\n}\n","export const getKeys = <T extends Record<string, unknown>>(o: T): (keyof T)[] =>\n  Object.keys(o) as (keyof T)[];\n","import type { EndRoute, LocalizedRoute } from \"./interfaces\";\nimport type { LocaleType, EndRoutePath } from \"./types\";\n\nexport class LocalizedEndRoute<Locales extends LocaleType, RouteRef>\n  implements\n    EndRoute<Locales, RouteRef>,\n    LocalizedRoute<EndRoutePath, Locales, RouteRef>\n{\n  localizedPaths: Map<LocaleType, EndRoutePath>;\n\n  ref: RouteRef;\n\n  constructor(localizedPaths: Map<LocaleType, EndRoutePath>, ref: RouteRef) {\n    this.localizedPaths = localizedPaths;\n\n    this.ref = ref;\n    Object.freeze(this);\n  }\n\n  getPath(locale?: Locales): EndRoutePath {\n    if (!locale) throw new Error(\"Missing locale\");\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { LocalizedEndRoute } from \"./LocalizedEndRoute\";\nimport type { SegmentRoute, LocalizedRoute } from \"./interfaces\";\nimport type { LocaleType, SegmentRoutePath } from \"./types\";\n\nexport class LocalizedSegmentRoute<Locales extends LocaleType, RouteRef>\n  implements\n    SegmentRoute<Locales, RouteRef>,\n    LocalizedRoute<SegmentRoutePath, Locales, RouteRef>\n{\n  localizedPaths: Map<Locales, SegmentRoutePath>;\n\n  nestedRoutes: LocalizedRoute<any, Locales, RouteRef>[] = [];\n\n  defaultRoute: LocalizedEndRoute<Locales, RouteRef> | undefined;\n\n  constructor(localizedPaths: Map<Locales, SegmentRoutePath>) {\n    this.localizedPaths = localizedPaths;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(locale?: Locales): SegmentRoutePath {\n    if (!locale) throw new Error(\"Missing locale\");\n    return this.localizedPaths.get(locale)!;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): true {\n    return true;\n  }\n\n  toJSON(): unknown[] {\n    return [...this.localizedPaths.entries()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { EndRoute, NotLocalizedRoute } from \"./interfaces\";\nimport type { EndRoutePath, LocaleType } from \"./types\";\n\nexport class NotLocalizedEndRoute<Locales extends LocaleType, RouteRef>\n  implements\n    EndRoute<Locales, RouteRef>,\n    NotLocalizedRoute<EndRoutePath, Locales, RouteRef>\n{\n  path: EndRoutePath;\n\n  ref: RouteRef;\n\n  constructor(path: EndRoutePath, ref: RouteRef) {\n    this.path = path;\n\n    this.ref = ref;\n    // Object.freeze(this);\n  }\n\n  getPath(): EndRoutePath {\n    return this.path;\n  }\n\n  isSegment(): false {\n    return false;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { NotLocalizedEndRoute } from \"./NotLocalizedEndRoute\";\nimport type { SegmentRoute, NotLocalizedRoute } from \"./interfaces\";\nimport type { LocaleType, SegmentRoutePath } from \"./types\";\n\nexport class NotLocalizedSegmentRoute<Locales extends LocaleType, RouteRef>\n  implements\n    SegmentRoute<Locales, RouteRef>,\n    NotLocalizedRoute<SegmentRoutePath, Locales, RouteRef>\n{\n  path: SegmentRoutePath;\n\n  nestedRoutes: NotLocalizedRoute<any, Locales, RouteRef>[] = [];\n\n  defaultRoute: NotLocalizedEndRoute<Locales, RouteRef> | undefined;\n\n  constructor(path: SegmentRoutePath) {\n    this.path = path;\n  }\n\n  freeze(): void {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(): SegmentRoutePath {\n    return this.path;\n  }\n\n  isSegment(): true {\n    return true;\n  }\n\n  isLocalized(): false {\n    return false;\n  }\n\n  toJSON(): unknown {\n    return this.path;\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { Key } from \"path-to-regexp\";\nimport { pathToRegexp, compile } from \"path-to-regexp\";\nimport type { SegmentRoutePath, EndRoutePath } from \"../types\";\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: true,\n): SegmentRoutePath;\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: false,\n): EndRoutePath;\n\nfunction internalCreateRoutePath(\n  path: string,\n  completePath: string,\n  segment: boolean,\n): EndRoutePath | SegmentRoutePath {\n  const keys: Key[] = [];\n  const regExp = pathToRegexp(segment ? `${path}/(.*)?` : path, keys, {\n    sensitive: true,\n    strict: true,\n  });\n  const namedParams = keys.map((key) => key.name).filter(Boolean);\n\n  if (segment) return { path, completePath, regExp, namedParams };\n\n  return {\n    path,\n    completePath,\n    regExp,\n    namedParams,\n    toPath: compile(completePath),\n  };\n}\n\nexport const createRoutePathSegment = (\n  path: string,\n  completePath: string,\n): SegmentRoutePath => internalCreateRoutePath(path, completePath, true);\n\nexport const createRoutePath = (\n  path: string,\n  completePath: string,\n): EndRoutePath => internalCreateRoutePath(path, completePath, false);\n","import type {\n  LocaleType,\n  LocalizedPathsRecord,\n  EndRoutePath,\n  SegmentRoutePath,\n} from \"../types\";\nimport { getKeys } from \"../utils/getKeys\";\nimport { LocalizedEndRoute } from \"./LocalizedEndRoute\";\nimport { LocalizedSegmentRoute } from \"./LocalizedSegmentRoute\";\nimport { NotLocalizedEndRoute as Route } from \"./NotLocalizedEndRoute\";\nimport { NotLocalizedSegmentRoute } from \"./NotLocalizedSegmentRoute\";\nimport { createRoutePath, createRoutePathSegment } from \"./createRoutePath\";\n\nconst createLocalizedPaths = <\n  Locales extends LocaleType,\n  Path extends EndRoutePath | SegmentRoutePath,\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  segment: boolean,\n): Map<Locales, Path> => {\n  const localizedPaths = new Map<Locales, Path>();\n  getKeys(localizedPathsRecord).forEach((locale: Locales) => {\n    const path = localizedPathsRecord[locale];\n    if (segment) {\n      const routerPath: SegmentRoutePath = createRoutePathSegment(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    } else {\n      const routerPath: EndRoutePath = createRoutePath(\n        path,\n        completeLocalizedPathsRecord[locale],\n      );\n      localizedPaths.set(locale, routerPath as Path);\n    }\n  });\n  return localizedPaths;\n};\n\nconst checkRef = <RouteRef>(ref: RouteRef): void => {\n  if (!ref) throw new Error(`Invalid ref: \"${JSON.stringify(ref)}\"`);\n};\n\nexport const createRoute = <Locales extends LocaleType, RouteRef>(\n  path: string,\n  completePath: string,\n  ref: RouteRef,\n): Route<Locales, RouteRef> => {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== \"production\") checkRef(ref);\n  const routePath: EndRoutePath = createRoutePath(path, completePath);\n  return new Route(routePath, ref);\n};\n\nexport const createLocalizedRoute = <Locales extends LocaleType, RouteRef>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n  ref: RouteRef,\n): LocalizedEndRoute<Locales, RouteRef> => {\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== \"production\") checkRef(ref);\n  const localizedPaths = createLocalizedPaths<Locales, EndRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    false,\n  );\n  return new LocalizedEndRoute(localizedPaths, ref);\n};\n\nexport const createSegmentRoute = <Locales extends LocaleType, RouteRef>(\n  path: string,\n  completePath: string,\n): NotLocalizedSegmentRoute<Locales, RouteRef> => {\n  const routePath = createRoutePathSegment(path, completePath);\n  return new NotLocalizedSegmentRoute(routePath);\n};\n\nexport const createLocalizedSegmentRoute = <\n  Locales extends LocaleType,\n  RouteRef,\n>(\n  localizedPathsRecord: LocalizedPathsRecord<Locales>,\n  completeLocalizedPathsRecord: LocalizedPathsRecord<Locales>,\n): LocalizedSegmentRoute<Locales, RouteRef> => {\n  const localizedPaths = createLocalizedPaths<Locales, SegmentRoutePath>(\n    localizedPathsRecord,\n    completeLocalizedPathsRecord,\n    true,\n  );\n  return new LocalizedSegmentRoute(localizedPaths);\n};\n","import type { LocalizedSegmentRoute, LocalizedEndRoute } from \"../routes\";\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from \"../routes/create\";\nimport type { EndRoute, SegmentRoute } from \"../routes/interfaces\";\nimport type { LocalizedPathsRecord, LocaleType } from \"../types\";\nimport { getKeys } from \"../utils/getKeys\";\n\nexport interface SegmentRouterBuilder<Locales extends LocaleType, RouteRef> {\n  add: (path: string, ref: RouteRef, key?: string) => void;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => void;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => void;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => void;\n  defaultRoute: (ref: RouteRef, key?: string) => void;\n}\n\nexport function createSegmentRouterBuilderCreator<\n  Locales extends LocaleType,\n  RouteRef,\n>(\n  defaultLocale: Locales | undefined,\n  addToRouteMap: (key: string, route: EndRoute<Locales, RouteRef>) => void,\n): (\n  segmentRoute: SegmentRoute<Locales, RouteRef>,\n) => SegmentRouterBuilder<Locales, RouteRef> {\n  const createSegmentRouterBuilder = (\n    segmentRoute: SegmentRoute<Locales, RouteRef>,\n  ): SegmentRouterBuilder<Locales, RouteRef> => {\n    const getCompletePath = (path: string, locale?: Locales): string =>\n      `${segmentRoute.getPath(locale).completePath}${path}`;\n\n    const getCompleteLocalizedPaths = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n    ): LocalizedPathsRecord<Locales> => {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const completeLocalizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n\n      getKeys(localizedPaths).forEach((locale: Locales) => {\n        completeLocalizedPaths[locale] = getCompletePath(\n          localizedPaths[locale],\n          locale,\n        );\n      });\n\n      return completeLocalizedPaths;\n    };\n\n    const createLocalizedPathFromSegment = (\n      segmentRoute: LocalizedSegmentRoute<Locales, RouteRef>,\n      path: string,\n    ): Record<Locales, string> => {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      const localizedPaths: Record<Locales, string> = {} as Record<\n        Locales,\n        string\n      >;\n      [...segmentRoute.localizedPaths.keys()].forEach((locale) => {\n        localizedPaths[locale] = path;\n      });\n      return localizedPaths;\n    };\n\n    const _createLocalizedEndRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ): LocalizedEndRoute<Locales, RouteRef> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const finalKey: string = key || completeLocalizedPaths[defaultLocale!];\n      const route = createLocalizedRoute(\n        localizedPaths,\n        completeLocalizedPaths,\n        ref,\n      );\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createEndRoute = (\n      path: string,\n      ref: RouteRef,\n      key?: string,\n    ): EndRoute<Locales, RouteRef> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedEndRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales, RouteRef>,\n            path,\n          ),\n          ref,\n          key,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createRoute(path, completePath, ref);\n      const finalKey: string = key || completePath;\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createLocalizedSegmentRoute = (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ): LocalizedSegmentRoute<Locales, RouteRef> => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const route = createLocalizedSegmentRoute<Locales, RouteRef>(\n        localizedPaths,\n        completeLocalizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    const _createSegmentRoute = (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ): SegmentRoute<Locales, RouteRef> => {\n      if (segmentRoute.isLocalized()) {\n        return _createLocalizedSegmentRoute(\n          createLocalizedPathFromSegment(\n            segmentRoute as LocalizedSegmentRoute<Locales, RouteRef>,\n            path,\n          ),\n          buildSegment,\n        );\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createSegmentRoute<Locales, RouteRef>(path, completePath);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    return {\n      defaultRoute: (ref: RouteRef, key?: string): void => {\n        segmentRoute.defaultRoute = _createEndRoute(\"\", ref, key);\n      },\n\n      add: (path: string, ref: RouteRef, key?: string): void => {\n        segmentRoute.nestedRoutes.push(_createEndRoute(path, ref, key));\n      },\n\n      addLocalized: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        ref: RouteRef,\n        key?: string,\n      ): void => {\n        if (!defaultLocale) throw new Error(\"Invalid locales\");\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedEndRoute(localizedPaths, ref, key),\n        );\n      },\n\n      addSegment: (\n        path: string,\n        buildSegment: (\n          builder: SegmentRouterBuilder<Locales, RouteRef>,\n        ) => void,\n      ): void => {\n        segmentRoute.nestedRoutes.push(_createSegmentRoute(path, buildSegment));\n      },\n\n      addLocalizedSegment: (\n        localizedPaths: LocalizedPathsRecord<Locales>,\n        buildSegment: (\n          builder: SegmentRouterBuilder<Locales, RouteRef>,\n        ) => void,\n      ): void => {\n        if (!defaultLocale) throw new Error(\"Invalid locales\");\n        segmentRoute.nestedRoutes.push(\n          _createLocalizedSegmentRoute(localizedPaths, buildSegment),\n        );\n      },\n    };\n  };\n  return createSegmentRouterBuilder;\n}\n","import type { Router } from \"../router/createRouter\";\nimport { createRouter } from \"../router/createRouter\";\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from \"../routes/create\";\nimport type { EndRoute } from \"../routes/interfaces\";\nimport type {\n  LocaleType,\n  LocalizedPathsRecord,\n  Routes,\n  RouteMap,\n} from \"../types\";\nimport type { SegmentRouterBuilder } from \"./createSegmentRouterBuilderCreator\";\nimport { createSegmentRouterBuilderCreator } from \"./createSegmentRouterBuilderCreator\";\n\nexport interface RouterBuilder<Locales extends LocaleType | never, RouteRef> {\n  add: (path: string, ref: RouteRef, key?: string) => this;\n  addLocalized: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    ref: RouteRef,\n    key?: string,\n  ) => this;\n  addLocalizedSegment: (\n    localizedPaths: LocalizedPathsRecord<Locales>,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => this;\n  addSegment: (\n    path: string,\n    buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n  ) => this;\n  createRouter: () => Router<Locales, RouteRef>;\n  getRoutes: () => Routes<Locales, RouteRef>;\n}\n\nexport function createRouterBuilder<Locales extends LocaleType, RouteRef>(\n  locales?: Locales[],\n): RouterBuilder<Locales, RouteRef> {\n  const defaultLocale = locales?.[0];\n  const routes: Routes<Locales, RouteRef> = [];\n  const routeMap: RouteMap<Locales, RouteRef> = new Map<\n    string,\n    EndRoute<Locales, RouteRef>\n  >();\n\n  const addToRouteMap = (\n    key: string,\n    route: EndRoute<Locales, RouteRef>,\n  ): void => {\n    if (routeMap.has(key)) throw new Error(`\"${key}\" is already used`);\n    routeMap.set(key, route);\n  };\n\n  const createSegmentRouterBuilder = createSegmentRouterBuilderCreator(\n    defaultLocale,\n    addToRouteMap,\n  );\n\n  const builder: RouterBuilder<Locales, RouteRef> = {\n    add: (path: string, ref: RouteRef, key?: string) => {\n      const route = createRoute(path, path, ref);\n      routes.push(route);\n      if (!key) key = path;\n      addToRouteMap(key, route);\n      return builder;\n    },\n\n    addLocalized: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      ref: RouteRef,\n      key?: string,\n    ) => {\n      if (!defaultLocale) throw new Error(\"Invalid locales\");\n      const route = createLocalizedRoute(localizedPaths, localizedPaths, ref);\n      routes.push(route);\n      const finalKey: string = key || localizedPaths[defaultLocale];\n      addToRouteMap(finalKey, route);\n      return builder;\n    },\n\n    addSegment: (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ) => {\n      const route = createSegmentRoute<Locales, RouteRef>(path, path);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n      return builder;\n    },\n\n    addLocalizedSegment: (\n      localizedPaths: LocalizedPathsRecord<Locales>,\n      buildSegment: (builder: SegmentRouterBuilder<Locales, RouteRef>) => void,\n    ) => {\n      if (!defaultLocale) throw new Error(\"Invalid locales\");\n      const route = createLocalizedSegmentRoute<Locales, RouteRef>(\n        localizedPaths,\n        localizedPaths,\n      );\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n      return builder;\n    },\n\n    getRoutes: () => routes,\n    createRouter: () => createRouter(routes, routeMap),\n  };\n  return builder;\n}\n"],"names":["Route","segmentRoute"],"mappings":"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"}