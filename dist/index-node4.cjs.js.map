{"version":3,"file":"index-node4.cjs.js","sources":["../src/routes/createRoutePath.js","../src/routes/EndRoute.js","../src/routes/LocalizedEndRoute.js","../src/routes/SegmentRoute.js","../src/routes/LocalizedSegmentRoute.js","../src/routes/create.js","../src/router/findMatch.js","../src/router/createRouter.js","../src/builder/createSegmentRouterBuilderCreator.js","../src/builder/createRouterBuilder.js"],"sourcesContent":["import pathToRegExp from 'path-to-regexp';\nimport type { SegmentRoutePathType, RoutePathType } from '../types';\n\nconst internalCreateRoutePath = (\n  path: string,\n  completePath: string,\n  segment: boolean,\n): SegmentRoutePathType | RoutePathType => {\n  const keys = [];\n  const regExp = pathToRegExp(segment ? `${path}/(.+)?` : path, keys, {\n    sensitive: true,\n    strict: true,\n  });\n  const namedParams = keys.map(key => key.name).filter(Boolean);\n\n  if (segment) return { path, completePath, regExp, namedParams };\n\n  return {\n    path,\n    completePath,\n    regExp,\n    namedParams,\n    toPath: pathToRegExp.compile(completePath),\n  };\n};\n\nexport const createRoutePathSegment = (path: string, completePath: string): SegmentRoutePathType =>\n  internalCreateRoutePath(path, completePath, true);\n\nexport const createRoutePath = (path: string, completePath: string): RoutePathType =>\n  internalCreateRoutePath(path, completePath, false);\n","import type { RoutePathType, RouteRefType } from './types';\n\nexport default class EndRoute {\n  path: RoutePathType;\n  ref: RouteRefType;\n\n  constructor(path: RoutePathType, ref: RouteRefType) {\n    this.path = path;\n    this.ref = ref;\n    // Object.freeze(this);\n  }\n\n  getPath(): RoutePathType {\n    return this.path;\n  }\n\n  isSegment(): boolean {\n    return false;\n  }\n\n  toJSON() {\n    return this.path;\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { LocaleType, RoutePathType, RouteRefType } from './types';\n\nexport default class LocalizedEndRoute {\n  localizedPaths: Map<LocaleType, RoutePathType>;\n  ref: RouteRefType;\n\n  constructor(localizedPaths: Map<LocaleType, RoutePathType>, ref: RouteRefType) {\n    this.localizedPaths = localizedPaths;\n    this.ref = ref;\n    Object.freeze(this);\n  }\n\n  getPath(locale: LocaleType): ?RoutePathType {\n    return this.localizedPaths.get(locale);\n  }\n\n  isSegment(): boolean {\n    return false;\n  }\n\n  toJSON() {\n    return Array.from(this.localizedPaths.entries());\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { SegmentRoutePathType } from './types';\nimport type Route from './EndRoute';\n\nexport default class SegmentRoute {\n  path: SegmentRoutePathType;\n  // nestedRoutes: Array<Route | SegmentRoute> = []; // disable flow: can cause issues with Object.freeze\n  nestedRoutes = [];\n  defaultRoute: ?Route;\n\n  constructor(path: SegmentRoutePathType) {\n    this.path = path;\n  }\n\n  freeze() {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(): SegmentRoutePathType {\n    return this.path;\n  }\n\n  isSegment(): boolean {\n    return true;\n  }\n\n  toJSON() {\n    return this.path;\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import type { LocaleType, SegmentRoutePathType } from './types';\nimport type LocalizedRoute from './LocalizedEndRoute';\n\nexport default class LocalizedSegmentRoute {\n  localizedPaths: Map<LocaleType, SegmentRoutePathType>;\n  nestedRoutes: Array<LocalizedRoute | LocalizedSegmentRoute> = [];\n  defaultRoute: ?LocalizedRoute;\n\n  constructor(localizedPaths: Map<LocaleType, SegmentRoutePathType>) {\n    this.localizedPaths = localizedPaths;\n  }\n\n  freeze() {\n    Object.freeze(this);\n    Object.freeze(this.nestedRoutes);\n  }\n\n  getPath(locale: LocaleType): ?SegmentRoutePathType {\n    return this.localizedPaths.get(locale);\n  }\n\n  isSegment(): boolean {\n    return true;\n  }\n\n  toJSON() {\n    return Array.from(this.localizedPaths.entries());\n  }\n\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n","import { createRoutePath, createRoutePathSegment } from './createRoutePath';\nimport type {\n  LocaleType,\n  PathDictionaryType,\n  RoutePathType,\n  SegmentRoutePathType,\n  RouteRefType,\n} from '../types';\nimport Route from './EndRoute';\nimport LocalizedRoute from './LocalizedEndRoute';\nimport SegmentRoute from './SegmentRoute';\nimport LocalizedSegmentRoute from './LocalizedSegmentRoute';\n\nconst createLocalizedPaths = (\n  pathDictionary: PathDictionaryType,\n  completePathDictionary: PathDictionaryType,\n  segment: boolean,\n) => {\n  const localizedPaths = new Map();\n  Object.keys(pathDictionary).forEach((locale: LocaleType) => {\n    const path = pathDictionary[locale];\n    if (segment) {\n      const routerPath: SegmentRoutePathType = createRoutePathSegment(\n        path,\n        completePathDictionary[locale],\n      );\n      localizedPaths.set(locale, routerPath);\n    } else {\n      const routerPath: RoutePathType = createRoutePath(path, completePathDictionary[locale]);\n      localizedPaths.set(locale, routerPath);\n    }\n  });\n  return localizedPaths;\n};\n\nconst checkRef = (ref: any) => {\n  if (!ref) throw new Error(`Invalid ref: \"${ref}\"`);\n};\n\nexport const createRoute = (path: string, completePath: string, ref: RouteRefType): Route => {\n  /* istanbul ignore else */\n  if (!PRODUCTION) checkRef(ref);\n  const routePath: RoutePathType = createRoutePath(path, completePath);\n  return new Route(routePath, ref);\n};\n\nexport const createLocalizedRoute = (\n  pathDictionary: PathDictionaryType,\n  completePathDictionary: PathDictionaryType,\n  ref: RouteRefType,\n): LocalizedRoute => {\n  /* istanbul ignore else */\n  if (!PRODUCTION) checkRef(ref);\n  const localizedPaths = createLocalizedPaths(pathDictionary, completePathDictionary, false);\n  return new LocalizedRoute(localizedPaths, ref);\n};\n\nexport const createSegmentRoute = (path: string, completePath: string): SegmentRoute => {\n  const routePath = createRoutePathSegment(path, completePath);\n  return new SegmentRoute(routePath);\n};\n\nexport const createLocalizedSegmentRoute = (\n  pathDictionary: PathDictionaryType,\n  completePathDictionary: PathDictionaryType,\n): LocalizedSegmentRoute => {\n  const localizedPaths = createLocalizedPaths(pathDictionary, completePathDictionary, true);\n  return new LocalizedSegmentRoute(localizedPaths);\n};\n","import Logger from 'nightingale-logger';\nimport type {\n  RoutesType,\n  LocaleType,\n  RouteMatchType,\n  SegmentRoutePathType,\n  RoutePathType,\n} from '../types';\nimport type { RouteType } from '../routes/index';\n\nconst logger = !PRODUCTION && new Logger('router-segments:findMatch');\n\nconst parseOtherParams = (wildcard: string) => (wildcard ? wildcard.split('/') : []);\n\nconst findMatch = (\n  path: string,\n  completePath: string,\n  routes: RoutesType,\n  locale: LocaleType,\n  namedParams: ?Map<string, string>,\n): ?RouteMatchType => {\n  let result = null;\n\n  routes.some((route: RouteType) => {\n    const routePath: ?SegmentRoutePathType | RoutePathType = route.getPath(locale);\n\n    if (!PRODUCTION && !routePath) {\n      throw new Error(`Unknown localized route for locale ${locale}`);\n    }\n\n    /* istanbul ignore next */\n    if (!PRODUCTION) logger.debug(`trying ${routePath.regExp}`);\n\n    const match = routePath.regExp.exec(path);\n    if (!match) return false;\n\n    match.shift(); // remove m[0], === path;\n\n    let groupCount = match.length;\n    let group = 0;\n\n    if (routePath.namedParams.length !== 0) {\n      // set params\n      if (!namedParams) namedParams = new Map();\n\n      routePath.namedParams.forEach((paramName: string) => {\n        namedParams.set(paramName, match[group++]);\n      });\n    }\n\n    if (route.isSegment()) {\n      const restOfThePath = match[--groupCount];\n\n      if (restOfThePath) {\n        result = findMatch(\n          `/${restOfThePath}`,\n          completePath,\n          route.nestedRoutes,\n          locale,\n          namedParams,\n        );\n\n        return result !== null;\n      }\n\n      if (!route.defaultRoute) {\n        return false;\n      }\n\n      route = route.defaultRoute;\n    }\n\n    const otherParams = group + 1 !== groupCount ? undefined : parseOtherParams(match[group]);\n\n    result = Object.freeze({\n      ref: route.ref,\n      path: completePath,\n      route,\n      routePath,\n      namedParams,\n      otherParams,\n    });\n\n    return true;\n  });\n\n  return result;\n};\n\nexport default (path: string, routes: RoutesType, locale: LocaleType = 'en'): ?RouteMatchType =>\n  findMatch(path, path, routes, locale);\n","import type { RoutesType, RouteMapType, RouterType, RouteMatchType } from '../types';\nimport type { EndRouteType } from '../routes';\nimport findMatch from './findMatch';\n\nexport default (routes: RoutesType, routeMap: RouteMapType): RouterType => {\n  const getRequiredRoute = (routeKey: string) => {\n    const route = routeMap.get(routeKey);\n    if (!route) throw new Error(`No route named \"${routeKey}\"`);\n    return route;\n  };\n\n  return {\n    get: (key: string): ?EndRouteType => getRequiredRoute(key),\n    find: (path: string, locale: ?string): ?RouteMatchType => findMatch(path, routes, locale),\n    toPath: (key: string, args: any): string => getRequiredRoute(key).getPath().toPath(args),\n    toLocalizedPath: (locale: string, key: string, args: any): string =>\n      getRequiredRoute(key).getPath(locale).toPath(args),\n  };\n};\n","import type { SegmentRouteType } from '../routes/index';\nimport type {\n  RouteType,\n  PathDictionaryType,\n  RouteRefType,\n  SegmentRouterBuilderType,\n} from '../types';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\n\ntype AddToRouteMapType = (key: string, route: RouteType) => void;\nexport default (defaultLocale: ?string, addToRouteMap: AddToRouteMapType) => {\n  const createSegmentRouterBuilder = (segmentRoute: SegmentRouteType) => {\n    const getCompletePath = path => segmentRoute.path.completePath + path;\n    const getCompleteLocalizedPaths = (localizedPaths: PathDictionaryType): PathDictionaryType => {\n      const completeLocalizedPaths = {};\n\n      const getCompletePathForLocale = !segmentRoute.localizedPaths\n        ? (path, locale) => `${segmentRoute.path.completePath}${path}`\n        : (path, locale) => `${segmentRoute.localizedPaths.get(locale).completePath}${path}`;\n\n      Object.keys(localizedPaths).forEach((locale: string) => {\n        completeLocalizedPaths[locale] = getCompletePathForLocale(localizedPaths[locale], locale);\n      });\n\n      return completeLocalizedPaths;\n    };\n\n    const createLocalizedPathFromSegment = (path: string) => {\n      const localizedPaths = {};\n      Array.from(segmentRoute.localizedPaths.keys()).forEach(\n        locale => (localizedPaths[locale] = path),\n      );\n      return localizedPaths;\n    };\n\n    const _createLocalizedEndRoute = (\n      localizedPaths: PathDictionaryType,\n      ref: RouteRefType,\n      key: ?string,\n    ) => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const finalKey: string = key || completeLocalizedPaths[defaultLocale];\n      const route = createLocalizedRoute(localizedPaths, completeLocalizedPaths, ref);\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createEndRoute = (path: string, ref: RouteRefType, key: ?string) => {\n      if (segmentRoute.localizedPaths) {\n        return _createLocalizedEndRoute(createLocalizedPathFromSegment(path), ref, key);\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createRoute(path, completePath, ref);\n      const finalKey: string = key || completePath;\n      addToRouteMap(finalKey, route);\n      return route;\n    };\n\n    const _createLocalizedSegmentRoute = (\n      localizedPaths: PathDictionaryType,\n      buildSegment: (builder: SegmentRouterBuilderType) => void,\n    ) => {\n      const completeLocalizedPaths = getCompleteLocalizedPaths(localizedPaths);\n      const route = createLocalizedSegmentRoute(localizedPaths, completeLocalizedPaths);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    const _createSegmentRoute = (\n      path: string,\n      buildSegment: (builder: SegmentRouterBuilderType) => void,\n    ) => {\n      if (segmentRoute.localizedPaths) {\n        return _createLocalizedSegmentRoute(createLocalizedPathFromSegment(path), buildSegment);\n      }\n\n      const completePath = getCompletePath(path);\n      const route = createSegmentRoute(path, completePath);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      return route;\n    };\n\n    return {\n      defaultRoute: (ref: RouteRefType, key: ?string) => {\n        segmentRoute.defaultRoute = _createEndRoute('', ref, key);\n      },\n\n      add: (path: string, ref: RouteRefType, key: ?string): void => {\n        segmentRoute.nestedRoutes.push(_createEndRoute(path, ref, key));\n      },\n\n      addLocalized: (localizedPaths: PathDictionaryType, ref: RouteRefType, key: ?string): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(_createLocalizedEndRoute(localizedPaths, ref, key));\n      },\n\n      addSegment: (\n        path: string,\n        buildSegment: (builder: SegmentRouterBuilderType) => void,\n      ): void => {\n        segmentRoute.nestedRoutes.push(_createSegmentRoute(path, buildSegment));\n      },\n\n      addLocalizedSegment: (\n        localizedPaths: PathDictionaryType,\n        buildSegment: (builder: SegmentRouterBuilderType) => void,\n      ): void => {\n        if (!defaultLocale) throw new Error('Invalid locales');\n        segmentRoute.nestedRoutes.push(_createLocalizedSegmentRoute(localizedPaths, buildSegment));\n      },\n    };\n  };\n  return createSegmentRouterBuilder;\n};\n","import type {\n  LocaleType,\n  RouterBuilderType,\n  PathDictionaryType,\n  RoutesType,\n  RouteMapType,\n  RouteType,\n  SegmentRouterBuilderType,\n  RouteRefType,\n} from '../types';\nimport {\n  createRoute,\n  createLocalizedRoute,\n  createSegmentRoute,\n  createLocalizedSegmentRoute,\n} from '../routes/create';\nimport createRouter from '../router/createRouter';\nimport createSegmentRouterBuilderCreator from './createSegmentRouterBuilderCreator';\n\nexport default (locales: ?Array<LocaleType>): RouterBuilderType => {\n  const defaultLocale = locales && locales[0];\n  const routes: RoutesType = [];\n  const routeMap: RouteMapType = new Map();\n\n  const addToRouteMap = (key: string, route: RouteType) => {\n    if (routeMap.has(key)) throw new Error(`\"${key}\" is already used`);\n    routeMap.set(key, route);\n  };\n\n  const createSegmentRouterBuilder = createSegmentRouterBuilderCreator(\n    defaultLocale,\n    addToRouteMap,\n  );\n\n  return {\n    add: (path: string, ref: RouteRefType, key: ?string): void => {\n      const route = createRoute(path, path, ref);\n      routes.push(route);\n      if (!key) key = path;\n      addToRouteMap(key, route);\n    },\n\n    addLocalized: (localizedPaths: PathDictionaryType, ref: RouteRefType, key: ?string): void => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedRoute(localizedPaths, localizedPaths, ref);\n      routes.push(route);\n      const finalKey: string = key || localizedPaths[defaultLocale];\n      addToRouteMap(finalKey, route);\n    },\n\n    addSegment: (path: string, buildSegment: (builder: SegmentRouterBuilderType) => void): void => {\n      const route = createSegmentRoute(path, path);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n    },\n\n    addLocalizedSegment: (\n      localizedPaths: PathDictionaryType,\n      buildSegment: (builder: SegmentRouterBuilderType) => void,\n    ): void => {\n      if (!defaultLocale) throw new Error('Invalid locales');\n      const route = createLocalizedSegmentRoute(localizedPaths, localizedPaths);\n      buildSegment(createSegmentRouterBuilder(route));\n      route.freeze();\n      routes.push(route);\n    },\n\n    getRoutes: () => routes,\n    createRouter: () => createRouter(routes, routeMap),\n  };\n};\n"],"names":["internalCreateRoutePath","path","completePath","segment","keys","regExp","pathToRegExp","namedParams","map","key","name","filter","Boolean","compile","createRoutePathSegment","createRoutePath","EndRoute","ref","JSON","stringify","toJSON","LocalizedEndRoute","localizedPaths","freeze","locale","get","Array","from","entries","SegmentRoute","nestedRoutes","LocalizedSegmentRoute","createLocalizedPaths","pathDictionary","completePathDictionary","Map","forEach","routerPath","set","createRoute","routePath","Route","createLocalizedRoute","LocalizedRoute","createSegmentRoute","createLocalizedSegmentRoute","parseOtherParams","wildcard","split","findMatch","routes","result","some","route","getPath","match","exec","shift","groupCount","length","group","paramName","isSegment","restOfThePath","defaultRoute","otherParams","undefined","Object","routeMap","getRequiredRoute","routeKey","Error","args","toPath","defaultLocale","addToRouteMap","createSegmentRouterBuilder","segmentRoute","getCompletePath","getCompleteLocalizedPaths","completeLocalizedPaths","getCompletePathForLocale","createLocalizedPathFromSegment","_createLocalizedEndRoute","finalKey","_createEndRoute","_createLocalizedSegmentRoute","buildSegment","_createSegmentRoute","push","locales","has","createSegmentRouterBuilderCreator","createRouter"],"mappings":"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"}